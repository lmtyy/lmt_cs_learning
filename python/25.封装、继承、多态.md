## 封装、继承、多态

好的！下面我将详细讲解Python中面向对象编程的三个关键特性：**封装（Encapsulation）**、**继承（Inheritance）**和**多态（Polymorphism）**，包括它们的概念、实现方式以及示例。

---

### 一、封装（Encapsulation）

#### 1. 概念

封装是面向对象的基本原则之一，指**将对象的属性和方法封装在类的内部，隐藏实现细节，只暴露必要的接口给外部使用**。封装可以提高程序的安全性和易维护性，防止外部随意修改对象的内部状态。

用一句话说：**数据和操作数据的方法绑定在一起，对外隐藏内部细节。**

---

#### 2. Python中如何实现封装？

Python没有像Java或C++一样的访问修饰符（`private`、`public`、`protected`），但有约定俗成的命名规则用来实现“封装”和“访问控制”：

| 访问级别            | 命名方式       | 是否可由外部访问             | 说明                     |
| ------------------- | -------------- | ---------------------------- | ------------------------ |
| 公开属性/方法       | 变量名直接写   | 可以随意访问                 | 默认就是公开的           |
| 受保护（protected） | 单下划线_开头  | 可以访问，但建议不直接访问   | 表示内部使用，子类可访问 |
| 私有（private）     | 双下划线__开头 | 不可直接外部访问（名称重整） | 伪私有，真正私有不存在   |

---

#### 3. 例子

```python
class Person:
    def __init__(self, name, age):
        self.name = name          # 公开属性
        self._gender = "未知"      # 受保护属性（约定）
        self.__age = age          # 私有属性，外部不能直接访问
    
    def get_age(self):           # 公开方法，访问私有属性
        return self.__age
    
    def set_age(self, age):      # 公开方法，设置私有属性
        if age > 0:
            self.__age = age
        else:
            print("非法年龄")

p = Person("Alice", 20)

print(p.name)       # 公开，访问正常
print(p._gender)    # 受保护，虽然能访问，不推荐
# print(p.__age)    # 报错，私有属性不能直接访问

print(p.get_age())  # 通过公开方法访问私有属性
p.set_age(25)       # 修改私有属性
print(p.get_age())
```

**注意：** Python的私有属性通过名称重整实现，`__age`会被改成`_Person__age`，通过`p._Person__age`也能访问，但不推荐！

---

### 二、继承（Inheritance）

#### 1. 概念

继承是面向对象的重要机制，指**一个类（子类）可以继承另一个类（父类）的属性和方法，获得父类的功能，并且可以扩展和重写**。实现代码复用，增强可扩展性。

---

#### 2. Python继承语法

```python
class 父类名:
    pass

class 子类名(父类名):
    pass
```

---

#### 3. 例子

```python
class Animal:
    def eat(self):
        print("动物会吃东西")

class Dog(Animal):        # Dog继承自Animal
    def bark(self):
        print("汪汪叫")

dog = Dog()
dog.eat()      # 继承自Animal
dog.bark()     # Dog自己的方法
```

---

#### 4. 重写（Override）

子类可以重写父类的方法，实现不同的行为。

```python
class Cat(Animal):
    def eat(self):
        print("猫吃鱼")

cat = Cat()
cat.eat()     # 输出：猫吃鱼 （重写了父类eat）
```

---

#### 5. 使用`super()`调用父类方法

有时子类想在重写方法时调用父类方法，可以用`super()`：

```python
class Bird(Animal):
    def eat(self):
        super().eat()  # 调用父类eat
        print("鸟喜欢吃虫子")

bird = Bird()
bird.eat()
# 输出：
# 动物会吃东西
# 鸟喜欢吃虫子
```

---

### 三、多态（Polymorphism）

#### 1. 概念

多态指**不同类的实例可以通过相同的接口调用各自不同的实现，从而表现出不同的行为**。多态提高了程序的灵活性和扩展性。

一句话总结：**同一操作作用于不同的对象，可以产生不同的效果。**

---

#### 2. Python中的多态体现

因为Python是动态类型语言，只要不同类有同名方法，就可以统一调用，体现多态。

---

#### 3. 例子（鸭子类型）

```python
class Dog:
    def speak(self):
        print("汪汪叫")

class Cat:
    def speak(self):
        print("喵喵叫")

def animal_speak(animal):
    animal.speak()  # 不关注animal具体是什么类，只要有speak方法即可

d = Dog()
c = Cat()

animal_speak(d)  # 汪汪叫
animal_speak(c)  # 喵喵叫
```

多态体现在**统一接口，不同实现**。

---

### 四、示例总结

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        print(f"{self.name}在发出声音")

class Dog(Animal):
    def speak(self):
        print(f"{self.name}汪汪叫")

class Cat(Animal):
    def speak(self):
        print(f"{self.name}喵喵叫")

animals = [Dog("小白"), Cat("小花")]

for animal in animals:
    animal.speak()   # 多态，根据对象不同调用不同版本的方法
```

---

### 五、总结

| 特性 | 含义                               | Python实现方式                | 作用                                     |
| ---- | ---------------------------------- | ----------------------------- | ---------------------------------------- |
| 封装 | 隐藏内部数据，限制外部访问         | 通过单下划线`_`和双下划线`__` | 防止数据被随意修改，提高安全性和可维护性 |
| 继承 | 子类继承父类属性和方法，复用和扩展 | 类定义时声明继承关系          | 代码复用，实现类之间的层次结构           |
| 多态 | 不同类对象对相同接口的响应不同     | 动态绑定、统一接口调用        | 提高程序灵活性，使程序可扩展与维护       |

---

## 