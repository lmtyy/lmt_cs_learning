## 容器类型：列表和元组

### 数据收纳盒

用来收纳数据的数据类型
收纳盒是一种序列

### 列表

特点：列表可以删除、增加、重排、替换序列中的元素（可变类型）

#### 创建列表

方法1:方括号法[ ]
方法2:指明类型法list()

```python
# 方法1：使用方括号 []
list1 = [1, 2, 3, "hello", True]  # 可以包含任意类型
print(list1)  # 输出: [1, 2, 3, 'hello', True]

# 方法2：使用 list() 函数
list2 = list((4, 5, 6))  # 传入一个可迭代对象（如元组）
print(list2)  # 输出: [4, 5, 6]

# 空列表
empty_list = []
print(empty_list)  # 输出: []
```

#### 列表方法

##### 1.访问元素

（1）通过索引访问

```python
fruits = ["apple", "banana", "cherry"]
print(fruits[0])  # 输出: "apple"（索引从0开始）
print(fruits[-1])  # 输出: "cherry"（-1表示最后一个元素）
```

（2）切片（Slice）

```python
numbers = [0, 1, 2, 3, 4, 5]
print(numbers[1:4])  # 输出: [1, 2, 3]（左闭右开）
print(numbers[:3])   # 输出: [0, 1, 2]（从头到索引2）
print(numbers[3:])   # 输出: [3, 4, 5]（从索引3到末尾）
print(numbers[::2])  # 输出: [0, 2, 4]（步长为2）
```

##### 2.修改列表

（1）修改单个元素

```python
fruits = ["apple", "banana", "cherry"]
fruits[1] = "orange"  # 修改索引1的元素
print(fruits)  # 输出: ["apple", "orange", "cherry"]
```

（2）修改多个元素（切片赋值）

```python
numbers = [1, 2, 3, 4, 5]
numbers[1:3] = [20, 30]  # 替换索引1和2的元素
print(numbers)  # 输出: [1, 20, 30, 4, 5]
```

##### 3.增加元素

（1）append( )-在末尾添加单个元素

```python
fruits = ["apple", "banana"]
fruits.append("cherry")
print(fruits)  # 输出: ["apple", "banana", "cherry"]
```

（2）extend( )-合并另一个列表

```python
fruits = ["apple", "banana"]
fruits.extend(["cherry", "orange"])
print(fruits)  # 输出: ["apple", "banana", "cherry", "orange"]
```

（3）insert( )-在制定位置插入元素

```python
fruits = ["apple", "cherry"]
fruits.insert(1, "banana")  # 在索引1处插入
print(fruits)  # 输出: ["apple", "banana", "cherry"]
```

##### 4.删除元素

（1）remove( )-删除指定值的元素

```python
fruits = ["apple", "banana", "cherry"]
fruits.remove("banana")  # 删除 "banana"
print(fruits)  # 输出: ["apple", "cherry"]
```

（2）pop( )-删除并返回指定索引的元素

```python
fruits = ["apple", "banana", "cherry"]
popped = fruits.pop(1)  # 删除索引1的元素
print(popped)  # 输出: "banana"
print(fruits)  # 输出: ["apple", "cherry"]
```

（3）del-删除指定索引或切片

```python
numbers = [1, 2, 3, 4, 5]
del numbers[0]  # 删除索引0的元素
print(numbers)  # 输出: [2, 3, 4, 5]

del numbers[1:3]  # 删除索引1到2的元素
print(numbers)  # 输出: [2, 5]
```

（4）clear( )-清空列表

```python
fruits = ["apple", "banana", "cherry"]
fruits.clear()
print(fruits)  # 输出: []
```

##### 5.查找元素

（1）index( )-返回元素的索引

```python
fruits = ["apple", "banana", "cherry"]
print(fruits.index("banana"))  # 输出: 1
```

（2）count( )-统计元素出现的次数

```python
numbers = [1, 2, 2, 3, 2]
print(numbers.count(2))  # 输出: 3
```

（3）in-检查元素是否存在

```python
fruits = ["apple", "banana", "cherry"]
print("banana" in fruits)  # 输出: True
print("orange" in fruits)  # 输出: False
```

##### 6.排序和反转

（1）sort( )-升序排序

```python
numbers = [3, 1, 4, 2]
numbers.sort()
print(numbers)  # 输出: [1, 2, 3, 4]
```

（2）sort(reverse=True)-降序排序

```python
numbers = [3, 1, 4, 2]
numbers.sort(reverse=True)
print(numbers)  # 输出: [4, 3, 2, 1]
```

（3）reverse( )-反转列表

```python
fruits = ["apple", "banana", "cherry"]
fruits.reverse()
print(fruits)  # 输出: ["cherry", "banana", "apple"]
```

（4）sorted( )-返回排序后的新列表（不影响原列表）

```python
numbers = [3, 1, 4, 2]
sorted_numbers = sorted(numbers)
print(sorted_numbers)  # 输出: [1, 2, 3, 4]
print(numbers)  # 原列表不变: [3, 1, 4, 2]
```

##### 7列表复制

（1）浅拷贝（copy（）或 list（）或  [:]）

```python
original = [1, 2, 3]
copy1 = original.copy()
copy2 = list(original)
copy3 = original[:]

copy1[0] = 99
print(original)  # 输出: [1, 2, 3]（原列表不受影响）
```

（2）深拷贝(嵌套列表时使用 copy.deepcopy( ) )

```python
import copy
original = [[1, 2], [3, 4]]
deep_copy = copy.deepcopy(original)
deep_copy[0][0] = 99
print(original)  # 输出: [[1, 2], [3, 4]]（原列表不受影响）
```

##### 8.列表推导式子（List Comprehension）

```python
# 生成平方列表
squares = [x**2 for x in range(5)]
print(squares)  # 输出: [0, 1, 4, 9, 16]

# 筛选偶数
numbers = [1, 2, 3, 4, 5]
evens = [x for x in numbers if x % 2 == 0]
print(evens)  # 输出: [2, 4]
```

##### 9.加法运算

语法：

```python
new_list = list1 + list2
```

list1和list2必须是列表（或其他可迭代对象需先转换为列表）
**返回一个新列表，不修改原列表**

```python
list1 = [1, 2, 3]
list2 = [4, 5, 6]
result = list1 + list2
print(result)  # 输出: [1, 2, 3, 4, 5, 6]
print(list1)   # 原列表不变: [1, 2, 3]
print(list2)   # 原列表不变: [4, 5, 6]
```

##### 10.长度、最大值、最小值

通用函数：len( ),max( ),min( ),sum( )(仅限数字序列)

```python
nums_list = [1, 2, 3]
nums_tuple = (4, 5, 6)

print(len(nums_list))    # 3
print(max(nums_tuple))   # 6
print(sum(nums_list))    # 6
```



### 元组

特点：元组是不能再更新（不可变序列）连数值也无法重新赋值，元组在保留列表大多数性能时，去掉了一些灵活性以换取更高的处理性能，元组的特点是必须有逗号

#### 创建元组

方法一：使用圆括号（）
方法二：使用tuple（）函数

```python
# 方法1：使用圆括号 ()
tuple1 = (1, 2, 3, "hello", True)
print(tuple1)  # 输出: (1, 2, 3, 'hello', True)

# 方法2：使用 tuple() 函数
tuple2 = tuple([4, 5, 6])  # 传入一个可迭代对象（如列表）
print(tuple2)  # 输出: (4, 5, 6)

# 空元组
empty_tuple = ()
print(empty_tuple)  # 输出: ()

# 单元素元组（注意逗号不能省略）
single_element_tuple = (42,)  # 必须加逗号
print(single_element_tuple)  # 输出: (42,)
```

#### 元组方法

##### 1.访问元组元素

（1）通过索引访问

```python
fruits = ("apple", "banana", "cherry")
print(fruits[0])   # 输出: "apple"（索引从0开始）
print(fruits[-1])   # 输出: "cherry"（-1表示最后一个元素）
```

（2）切片（Slice）

```python
numbers = (0, 1, 2, 3, 4, 5)
print(numbers[1:4])  # 输出: (1, 2, 3)（左闭右开）
print(numbers[:3])   # 输出: (0, 1, 2)（从头到索引2）
print(numbers[3:])   # 输出: (3, 4, 5)（从索引3到末尾）
print(numbers[::2])  # 输出: (0, 2, 4)（步长为2）
```

##### 2.元组不可变（无法修改）

元组创建后，不能修改、删除或添加元素，否则会报错：

```python
fruits = ("apple", "banana", "cherry")

# 尝试修改会报错
# fruits[0] = "orange"  # ❌ TypeError: 'tuple' object does not support item assignment

# 尝试删除会报错
# del fruits[1]  # ❌ TypeError: 'tuple' object doesn't support item deletion
```

**变通方法：转换成列表修改后再转回元组**

```python
fruits = ("apple", "banana", "cherry")
temp_list = list(fruits)  # 转成列表
temp_list[1] = "orange"  # 修改
fruits = tuple(temp_list)  # 转回元组
print(fruits)  # 输出: ("apple", "orange", "cherry")
```

##### 3.元组查询操作

（1）index( )-返回元素的索引

```python
fruits = ["apple", "banana", "cherry"]
print(fruits.index("banana"))  # 输出: 1
```

（2）count( )-统计元素出现的次数

```python
numbers = [1, 2, 2, 3, 2]
print(numbers.count(2))  # 输出: 3
```

（3）in-检查元素是否存在

```python
fruits = ["apple", "banana", "cherry"]
print("banana" in fruits)  # 输出: True
print("orange" in fruits)  # 输出: False
```

##### 4.元素拼接

（1）+运算符（合并元组）

```python
tuple1 = (1, 2, 3)
tuple2 = (4, 5, 6)
combined = tuple1 + tuple2
print(combined)  # 输出: (1, 2, 3, 4, 5, 6)
```

（2）* 运算符（重复元组）

```python
numbers = (1, 2)
repeated = numbers * 3
print(repeated)  # 输出: (1, 2, 1, 2, 1, 2)
```

##### 5.元组解包(Unpacking)

```python
person = ("Alice", 25, "Engineer")
name, age, job = person  # 解包赋值
print(name)  # 输出: "Alice"
print(age)   # 输出: 25
print(job)   # 输出: "Engineer"
```

使用 * 收集剩余元素

```python
numbers = (1, 2, 3, 4, 5)
first, *middle, last = numbers
print(first)   # 输出: 1
print(middle)  # 输出: [2, 3, 4]（自动转为列表）
print(last)    # 输出: 5
```

##### 6.元组遍历

（1）for循环遍历

```python
fruits = ("apple", "banana", "cherry")
for fruit in fruits:
    print(fruit)
```

输出：

```txt
apple
banana
cherry
```

（2）enumerate( )获取索引和值

```python
fruits = ("apple", "banana", "cherry")
for idx, fruit in enumerate(fruits):
    print(f"Index {idx}: {fruit}")
```

输出：

```text
Index 0: apple
Index 1: banana
Index 2: cherry
```

##### 7.长度、最大值、最小值

通用函数：len( ),max( ),min( ),sum( )(仅限数字序列)

```python
nums_list = [1, 2, 3]
nums_tuple = (4, 5, 6)

print(len(nums_list))    # 3
print(max(nums_tuple))   # 6
print(sum(nums_list))    # 6
```

### 标签收纳盒

给数据贴上标签，就可以通过具有特定含义的名字或者别的记号来获取数据

### 字典

字典（Dictionary）是Python中一种非常强大且常用的数据结构，它提供了键值对（key-value）存储机制。

#### 字典的特性

1.键（key）必须是不可变类型（如字符串、数字、元组），且唯一
2.值（value）可以是任意的Python对象
3.字典是无序的
4.字典是动态的，可以随时添加、修改或删除键值对
5.字典中的元素叫做数据项（item），数据项中包含标签-数据值（key-value）
6.一个键只能对应一个值

#### 创建字典

字典是可变的无序集合，用花括号{ }表示，元素形式为key：value

```python
# 创建字典
my_dict = {'name': 'Alice', 'age': 25, 'city': 'New York'}
empty_dict = {}  # 空字典
```

#### 字典方法

##### 1.访问元素

```python
print(my_dict['name'])  # 输出: Alice

# 使用get()方法更安全，可以指定默认值
print(my_dict.get('age'))  # 输出: 25
print(my_dict.get('job', 'Not specified'))  # 输出: Not specified
```

##### 2.添加修改元素

```python
my_dict['job'] = 'Engineer'  # 添加新键值对
my_dict['age'] = 26  # 修改已有键的值
```

##### 3.删除元素

```python
del my_dict['city']  # 删除指定键值对
age = my_dict.pop('age')  # 删除并返回指定键的值
my_dict.clear()  # 清空字典

#popitem删除并返回最后插入的键值对
d = {'a': 1, 'b': 2}
print(d.popitem())  # ('b', 2)
print(d)           # {'a': 1}
```

##### 4.常用方法

```python
# keys（）获取所有键
d = {'a': 1, 'b': 2}
keys = d.keys()
print(keys)       # dict_keys(['a', 'b'])
d['c'] = 3        # 视图会动态更新
print(keys)       # dict_keys(['a', 'b', 'c'])

# values（）获取所有值
d = {'a': 1, 'b': 2}
vals = d.values()
print(vals)       # dict_values([1, 2])
d['a'] = 10       # 视图会动态更新
print(vals)       # dict_values([10, 2])

# items（）获取所有键值对
d = {'a': 1, 'b': 2}
items = d.items()
print(items)      # dict_items([('a', 1), ('b', 2)])
d['c'] = 3        # 视图会动态更新
print(items)      # dict_items([('a', 1), ('b', 2), ('c', 3)])

#获取值如果键不存在则设置默认值
d = {'a': 1}
print(d.setdefault('a', 100))  # 1 (已存在)
print(d.setdefault('b', 2))    # 2 (新增)
print(d)  # {'a': 1, 'b': 2}

# 检查键是否存在
if 'name' in my_dict:
    print("Name exists")

# 更新字典
my_dict.update({'age': 27, 'gender': 'female'})

# 字典长度
length = len(my_dict)
```

##### 5.遍历字典

```python
# 遍历键
for key in my_dict:
    print(key)

# 遍历键值对
for key, value in my_dict.items():
    print(f"{key}: {value}")
```

##### 6.字典浅拷贝（copy()）

```python
d = {'a': 1, 'b': [2, 3]}
d_copy = d.copy()
d['a'] = 10
d['b'].append(4)
print(d)      # {'a': 10, 'b': [2, 3, 4]}
print(d_copy) # {'a': 1, 'b': [2, 3, 4]} (注意列表被共享)
```

##### 7.字典深拷贝（deepcopy( )）

如果想完全独立拷贝字典，包括里面的可变对象，可以用标准库的 `copy` 模块中的`deepcopy`：

```python
import copy
d_copy = copy.deepcopy(d)
```

这样，`d_copy['b']` 会是 `d['b']` 的一个全新、互不影响的列表。

##### 8.fromkeys(iterable, value)-从可迭代对象创建新字典，所有值相同

```python
keys = ['a', 'b', 'c']
d = dict.fromkeys(keys, 0)
print(d)  # {'a': 0, 'b': 0, 'c': 0}
```

##### 9.字典推导式

类似列表推导式，可以快速创建字典

```python
# 创建平方字典
squares = {x: x*x for x in range(5)}
print(squares)  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

# 条件筛选
even_squares = {x: x*x for x in range(10) if x % 2 == 0}
```

##### 10.特殊字典类型

Python还提供了一些特殊的字典类型：

- `collections.defaultdict` - 提供默认值的字典

  自动为不存在的键提供默认值

  ```python
  from collections import defaultdict
  dd = defaultdict(int)
  print(dd['a'])  # 0 (默认值)
  ```

- `collections.OrderedDict` - 保持插入顺序的字典

  保持插入顺序的字典

  ```python
  from collections import OrderedDict
  od = OrderedDict()
  od['a'] = 1
  od['b'] = 2
  print(list(od.keys()))  # ['a', 'b']
  ```

- `collections.Counter` - 用于计数的字典

  ```python
  from collections import Counter
  
  # 统计列表中各元素出现的次数
  words = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple']
  word_counts = Counter(words)
  
  print(word_counts)
  # 输出: Counter({'apple': 3, 'banana': 2, 'orange': 1})
  ```

##### 11.实际应用示例

```python
# 统计单词频率
text = "hello world hello python world python python"
words = text.split()
word_count = {}

for word in words:
    word_count[word] = word_count.get(word, 0) + 1

print(word_count)
# 输出: {'hello': 2, 'world': 2, 'python': 3}
```

### 集合

集合（Set）是Python中的一种内置数据类型，用于存储**无序、不重复**的元素集合。集合在Python中非常有用，特别是在需要快速成员测试、去重或执行数学集合操作（如并集、交集等）时。

#### 标签袋

通过改造字典类型，去掉关联数据值，只留下标签的新容器类型

#### 集合的特性

1.python中的集合类似于数学中的集合
2.无序性：集合中的元素没有固定顺序
3.唯一性：集合中的元素都是唯一的（自动去重）
4.可变性：集合本身是可变的，但集合中的元素必须是不可变类型（如数字、字符串、元组等）

#### 创建集合

```python
# 使用花括号创建集合
fruits = {'apple', 'banana', 'orange'}
print(fruits)  # 输出可能是 {'banana', 'orange', 'apple'}（顺序不确定）

# 使用set()函数创建集合
numbers = set([1, 2, 3, 4, 5])
print(numbers)  # 输出 {1, 2, 3, 4, 5}

# 空集合必须用set()创建，不能用{}（{}创建的是空字典）
empty_set = set()
```

#### 集合操作

##### 1.集合操作

```python
# 添加元素
fruits.add('grape')

# 移除元素
fruits.remove('banana')  # 如果元素不存在会引发KeyError
fruits.discard('banana')  # 安全移除，元素不存在也不会报错

# 随机弹出一个元素
popped = fruits.pop()

# 清空集合
fruits.clear()

# 获取集合长度
len(fruits)
```

##### 2.集合运算

```python
a = {1, 2, 3, 4}
b = {3, 4, 5, 6}

# 并集
print(a | b)  # {1, 2, 3, 4, 5, 6}
print(a.union(b))  # 同上

# 交集
print(a & b)  # {3, 4}
print(a.intersection(b))  # 同上

# 差集（在a中但不在b中）
print(a - b)  # {1, 2}
print(a.difference(b))  # 同上

# 对称差集（仅在a或仅在b中的元素）
print(a ^ b)  # {1, 2, 5, 6}
print(a.symmetric_difference(b))  # 同上
```

##### 3.集合比较

```python
x = {1, 2}
y = {1, 2, 3}

# 子集检查
print(x <= y)  # True
print(x.issubset(y))  # True

# 真子集检查
print(x < y)  # True

# 超集检查
print(y >= x)  # True
print(y.issuperset(x))  # True

# 真超集检查
print(y > x)  # True
```

##### 4.集合推导式

类似于列表推导式，Python也支持集合推导式

```python
squares = {x**2 for x in range(10)}
print(squares)  # {0, 1, 4, 9, 16, 25, 36, 49, 64, 81}
```

##### 5.不可变集合

```python
fs = frozenset([1, 2, 3])
# fs.add(4)  # 会报错，因为frozenset不可变
```

#### 应用场景

1.快速成员测试（比列表快很多）
2.数据去重
3.数据集合运算
4.过滤重复项

### 不可变类型与可变类型

灵活性强会花费一些计算或者存储的代价去维持这些强大的功能

#### 不可变类型

一旦创建就无法修改的数据类型，有整数、浮点数、复数、字符串、逻辑值、元表

##### 1.整数

```python
a = 10
a += 1  # 实际上是创建了新对象，a 指向新的内存地址。
```

##### 2.浮点数

```python
b = 3.14
b += 1  # 新对象被创建。
```

##### 3.布尔值（bool）

```python
c = True
c = False  # 新对象。
```

##### 4.字符串（str）

```python
s = "hello"
s += " world"  # 新字符串对象，原字符串不可变。
```

##### 5.元组（tuple）

```python
t = (1, 2, 3)
# t[0] = 10  # 报错！元组不可修改。
```

##### 6.不可变集合（frozenset）

```python
fs = frozenset([1, 2, 3])
```

#### **不可变类型特点**

1.修改时会创建新对象，原对象不变
2.适合作为字典的键（如tuple、str、int），因为哈希值不可变

#### 可变类型

可以随时改变的数据类型，有列表、字典、集合、字节数组

##### 1.列表

```python
lst = [1, 2, 3]
lst.append(4)  # 直接修改原列表。
```

##### 2.字典

```python
d = {"a": 1}
d["b"] = 2  # 直接修改原字典。
```

##### 3.集合

```python
s = {1, 2, 3}
s.add(4)  # 直接修改原集合。
```

##### 4.字节数组

```python
ba = bytearray(b"hello")
ba[0] = 72  # 直接修改。
```

#### **注意：**

**多个变量通过赋值引用同一个可变类型对象时，通过其中任何一个变量改变了可变类型对象，其他变量也随之改变**

##### 案例1:列表（list）的共享引用

```python
# 两个变量 a 和 b 引用同一个列表
a = [1, 2, 3]
b = a  # b 和 a 指向同一个列表

# 通过 b 修改列表
b.append(4)

print(a)  # 输出: [1, 2, 3, 4] （a 也被修改！）
print(b)  # 输出: [1, 2, 3, 4]
print(a is b)  # 输出: True （是同一个对象）
```

**关键点：a和b是同一个列表对象的两个别名，修改其中一个会影响另一个**

##### 案例2:字典（dict）的共享引用

```python
# 两个变量指向同一个字典
dict1 = {"name": "Alice"}
dict2 = dict1  # dict2 和 dict1 引用同一个字典

# 通过 dict2 修改字典
dict2["age"] = 25

print(dict1)  # 输出: {'name': 'Alice', 'age': 25} （dict1 也被修改！）
print(dict2)  # 输出: {'name': 'Alice', 'age': 25}
```

##### 案例3:集合（set）的共享引用

```python
# 两个变量引用同一个集合
set1 = {1, 2, 3}
set2 = set1  # set2 和 set1 指向同一个集合

# 通过 set2 修改集合
set2.add(4)

print(set1)  # 输出: {1, 2, 3, 4} （set1 也被修改！）
print(set2)  # 输出: {1, 2, 3, 4}
```

##### 出现该现象的原因

- 可变对象（如列表、字典、集合）在内存中只有一份副本，所有赋值操作只是创建新的引用（别名），而不是创建新对象。
- 修改对象时，所有引用该对象的变量都会看到变化。

##### 如何避免意外修改

如果需要独立副本，需显式复制对象：
1.**浅拷贝（Shallow Copy）**

- 适用于简单嵌套的可变对象（如单层列表）。

```python
a = [1, 2, 3]
b = a.copy()  # 或 b = a[:] （创建新列表）

b.append(4)
print(a)  # 输出: [1, 2, 3] （a 未被修改）
print(b)  # 输出: [1, 2, 3, 4]
```

#### 2. **深拷贝（Deep Copy）**

- 适用于多层嵌套的可变对象（如列表中的列表）。

```python
import copy

a = [[1, 2], [3, 4]]
b = copy.deepcopy(a)  # 完全独立的新对象

b[0][0] = 99
print(a)  # 输出: [[1, 2], [3, 4]] （a 不变）
print(b)  # 输出: [[99, 2], [3, 4]]
```

