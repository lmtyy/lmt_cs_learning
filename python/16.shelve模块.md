## shelve模块

`shelve`模块提供了一个简单的对象持久化功能，它实现了一个类似字典的接口，可以将Python对象（只要是**可pickle对象**）存储到一个文件中，从而实现数据的持久化保存和读取。

简单来说，`shelve`就是用一个文件当“数据库”，你可以像操作字典一样操作这个文件，把Python对象以键值对形式保存起来。

---

### shelve的应用场景

- 需要持久化保存Python对象，方便下次程序运行时加载这些数据。
- 不想用关系型数据库或者安装第三方数据库时，`shelve`是快速存储少量数据的轻量级方案。
- 实现配置存储、缓存、简单数据备份等。

---

### shelve模块的基本用法

```python
import shelve

# 打开一个shelve文件，文件名就是数据库名
with shelve.open('mydata.db') as db:
    # 写入数据
    db['name'] = 'Alice'
    db['age'] = 30
    db['scores'] = [95, 88, 92]

# 读取数据
with shelve.open('mydata.db') as db:
    print(db['name'])    # Alice
    print(db.get('age')) # 30

    # 遍历所有键值
    for key in db:
        print(key, db[key])
```

---

### shelve模块主要特点

- **数据以键值对存储**，键必须是字符串（从Python 3.4开始，键也可以是其他类型，但一般推荐用字符串），值可以是任意Python对象（只要能pickle）。
- 底层实现依赖于`dbm`等数据库模块（平台相关），底层用的是二进制文件。
- 每次修改后会自动写回文件。
- 适合存储简单的数据，不适合复杂并发访问需求。

---

### shelve模块常用函数和方法

`shelve.open(filename, flag='c', protocol=None, writeback=False)`

| 参数        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| `filename`  | 文件名（存储数据库的路径，无需扩展名，底层会自动加后缀）     |
| `flag`      | 文件打开模式：'r'(只读)，'w'(读写需存在文件)，'c'(读写，文件不存在则创建，默认)，'n'(新建，覆盖原文件) |
| `protocol`  | 指定pickle的协议版本，默认使用最高协议                       |
| `writeback` | 是否启用写回缓存，默认False。若为True，改动缓存后才能写回到文件，性能低但方便复杂对象修改 |

---

打开后返回一个类似字典的对象（`Shelf`对象），常用方法：

| 方法              | 说明                               |
| ----------------- | ---------------------------------- |
| `db[key] = value` | 设置键值                           |
| `value = db[key]` | 获取对应键的值                     |
| `key in db`       | 判断键是否存在                     |
| `del db[key]`     | 删除键及对应数据                   |
| `db.keys()`       | 返回所有键的列表                   |
| `db.values()`     | 返回所有值的列表                   |
| `db.items()`      | 返回所有键值对的列表               |
| `db.close()`      | 关闭shelve数据库，确保数据写入磁盘 |

### writeback参数说明

- 默认为`False`，变更对象需重新赋值才能写回。

```python
import shelve

with shelve.open('mydata.db') as db:
    db['numbers'] = [1, 2, 3]

with shelve.open('mydata.db') as db:
    # 直接修改列表不会写回
    db['numbers'].append(4)
    print(db['numbers'])  # [1, 2, 3, 4]
    # 关闭后再打开，变化没有保存因为没重新赋值
```

- 设为`writeback=True`可缓存内容，修改后自动写回，但性能较慢，适用于复杂可变对象。

---

### 示例和读取对象

```python
import shelve

data = {
    'name': 'Bob',
    'age': 25,
    'courses': ['math', 'physics']
}

# 存储数据
with shelve.open('student.db') as db:
    for key, value in data.items():
        db[key] = value

# 读取数据
with shelve.open('student.db') as db:
    print(db['name'])         # Bob
    print(db.get('courses'))  # ['math', 'physics']
```

---

### 注意事项

- shelve对同一个文件不能多进程并发写入，容易导致数据损坏。
- 数据库文件的具体扩展名和实现依赖系统上的dbm库，不同平台文件可能不同。
- 不要把数据库文件直接删除或手动改写，否则可能导致数据丢失。
- 在修改可变对象（如列表、字典）时，需注意是否使用`writeback=True`以确保写回。

---

### 总结

| 优点                     | 缺点                                     |
| ------------------------ | ---------------------------------------- |
| 使用字典接口，简单易用   | 并发支持差，不能多个进程写同一文件       |
| 支持存储任意pickle对象   | 底层依赖平台，文件存在兼容差异           |
| 标准库，无需安装额外模块 | 适用数据量有限，不适合大数据和高性能需求 |

---



Python中的对象持久化，指的是将内存中的对象状态保存到存储介质（如文件、数据库）中，以便后续程序运行时能够恢复使用。这种技术在数据存储、缓存、配置保存等场景非常有用。