## 上下文管理器

上下文管理器是一种对象，它定义了进入和退出某个“上下文”的行为，确保无论代码如何执行完毕，都能正确地清理使用的资源，比如关闭文件、释放锁等。

Python中的上下文管理器主要通过`with`语句使用。

---

### 1. 上下文管理器的作用

- 简化资源管理代码，防止忘记释放资源导致内存泄漏、文件句柄泄漏等问题。
- 保证即使出现异常，也会执行资源释放代码。
- 常用于文件操作、数据库连接、线程锁和事务管理等场景。

---

### 2. 上下文管理器的接口

要成为上下文管理器，必须实现以下两个方法：

- `__enter__(self)`  
  进入上下文时调用。返回值会赋给`with ... as ...`中`as`后的变量。
- `__exit__(self, exc_type, exc_val, exc_tb)`  
  退出上下文时调用。参数为异常类型、异常值、追踪信息，如果不发生异常这三个参数均为`None`。

---

### 3. 使用上下文管理器的`with`语法

```python
with context_manager as var:
    # 在这里使用var
    ...
```

等价于：

```python
cm = context_manager
var = cm.__enter__()
try:
    # 使用var
    ...
except Exception as e:
    if not cm.__exit__(type(e), e, e.__traceback__):
        raise
else:
    cm.__exit__(None, None, None)
```

也就是说，`__exit__`方法有机会处理异常，若返回`True`，异常会被吞掉，否则继续抛出。

---

### 4. Python内置的上下文管理器示例

#### 文件操作

```python
with open('file.txt', 'r', encoding='utf-8') as f:
    content = f.read()
# 使用with保证文件关闭，无论读取是否成功文件都关闭
```

这就是一个典型的上下文管理器用例。

---

### 5. 自定义上下文管理器方法一：定义类并实现接口

示例：自定义一个上下文管理器，打印进入和退出提示。

```python
class MyContext:
    def __enter__(self):
        print('进入上下文')
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        print('退出上下文')
        if exc_type:
            print(f'异常类型: {exc_type}')
        # 返回False表示不处理异常，继续抛出
        return False

with MyContext() as ctx:
    print('正在运行上下文代码')
    # raise Exception('测试异常')
```

输出：

```
进入上下文
正在运行上下文代码
退出上下文
```

如果取消注释异常代码，异常信息会被打印，且异常仍会抛出。

---

### 6. 自定义上下文管理器方法二：用 `contextlib` 模块简化

Python的`contextlib`模块提供了装饰器`@contextmanager`，可以用生成器函数轻松创建上下文管理器。

示例：

```python
from contextlib import contextmanager

@contextmanager
def my_context():
    print('进入上下文')
    try:
        yield '上下文资源'
    finally:
        print('退出上下文')

with my_context() as resource:
    print(f'使用资源: {resource}')
```

输出：

```
进入上下文
使用资源: 上下文资源
退出上下文
```

这里，`yield`之前的代码对应`__enter__`，`yield`之后的代码对应`__exit__`。

---

### 7. 上下文管理器更多用法示例

#### 文件上下文管理器（我们自己写一个简化版）

```python
class FileOpener:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None

    def __enter__(self):
        self.file = open(self.filename, self.mode)
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.file:
            self.file.close()
```

使用：

```python
with FileOpener('test.txt', 'w') as f:
    f.write('Hello context manager!')
```

就比普通的open操作更清晰地展示了上下文管理器原理。

---

### 8. `__exit__`方法参数详解

`__exit__(self, exc_type, exc_val, exc_tb)` 接受三个参数：

- `exc_type`：异常类型，若无异常为`None`
- `exc_val`：异常实例
- `exc_tb`：异常的traceback对象

如果处理异常成功，`__exit__`应返回`True`，这样异常不会向上传播。

---

### 9. 总结

| 知识点             | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| 上下文管理器作用   | 优雅管理资源，避免泄漏，保证异常时也释放资源                 |
| 必须方法           | `__enter__()` 和 `__exit__(exc_type, exc_val, exc_tb)`       |
| `with`语句等价代码 | 调用`__enter__()`进入上下文，执行代码块，调用`__exit__()`退出上下文 |
| contextlib简化工具 | `@contextmanager`装饰器，基于生成器快速创建上下文管理器      |
| 常见应用           | 文件操作、数据库连接、线程锁、临时改变环境、事务控制等       |

## 