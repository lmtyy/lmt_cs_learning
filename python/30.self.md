## self

---

### 一、什么是 `self`？

- `self` 是实例方法的第一个参数，表示**调用该方法的对象本身**。
- 它类似于其他语言中的`this`指针，但必须显式声明。
- 在实例方法中通过`self`访问实例属性和其他方法。

---

### 二、为什么需要 `self`？

Python的方法定义是**函数定义**，把实例当作显式参数传入，因此需要一个变量名来代表这个实例。

例如：

```python
class Person:
    def say_hello(self):
        print("Hello!")

p = Person()
p.say_hello()
```

调用`p.say_hello()`时，Python会自动把`p`作为第一个参数传给方法，等价于`Person.say_hello(p)`。

---

### 三、`self`的作用

- 访问当前实例的属性和方法：

```python
class Person:
    def __init__(self, name):
        self.name = name  # 给实例绑定属性

    def say_hello(self):
        print(f"Hello, my name is {self.name}")

p = Person("Alice")
p.say_hello()  # 输出：Hello, my name is Alice
```

- 通过`self`维护实例自身状态。

---

### 四、`self`的命名规则

- 虽然约定俗成用`self`，但实际可以用任何合法变量名代替。
- 为了代码易读，强烈推荐使用`self`。

示例：

```python
class Person:
    def say_hello(this):
        print("Hello!")

p = Person()
p.say_hello()  # Hello!
```

这里`this`就是`self`，同理，调用`p.say_hello()`时，`p`会作为第一个参数绑定给`this`。

---

### 五、类方法和静态方法对`self`的区别

- **实例方法**：第一个参数是`self`，表示实例对象。
- **类方法**：用`@classmethod`装饰，第一个参数是`cls`，表示类对象。
- **静态方法**：用`@staticmethod`装饰，没有默认参数，不接收实例或类。

示例：

```python
class MyClass:
    def instance_method(self):
        print(f"实例方法，self是{self}")

    @classmethod
    def class_method(cls):
        print(f"类方法，cls是{cls}")

    @staticmethod
    def static_method():
        print("静态方法，没有self或cls参数")

obj = MyClass()
obj.instance_method()
MyClass.class_method()
MyClass.static_method()
```

---

### 六、总结

| 特性     | 是否需要 `self`         | 说明                   |
| -------- | ----------------------- | ---------------------- |
| 实例方法 | 需要                    | 通过`self`访问实例     |
| 类方法   | 不需要`self`，需要`cls` | 访问类属性或方法       |
| 静态方法 | 不需要                  | 类似普通函数，和类无关 |

`self`是Python面向对象中引用当前实例的约定，理解它是学好类和实例的关键。