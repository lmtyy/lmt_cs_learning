# Java中的流(Stream)概念

在Java中，"流"(Stream)是一个非常重要的概念，主要分为两种类型：

## 1. I/O流 (java.io包)

I/O流用于处理输入/输出操作，是Java中最早引入的流概念。

### 基本分类：

**按数据流向**：
- **输入流(InputStream/Reader)**：从数据源读取数据
- **输出流(OutputStream/Writer)**：向目标写入数据

**按数据类型**：
- **字节流**：以字节(8位)为单位
  - `InputStream` (抽象类)
  - `OutputStream` (抽象类)
  
- **字符流**：以字符(16位Unicode)为单位
  - `Reader` (抽象类)
  - `Writer` (抽象类)

### 常用实现类：

| 字节流 | 字符流 |
|--------|--------|
| `FileInputStream` | `FileReader` |
| `FileOutputStream` | `FileWriter` |
| `ByteArrayInputStream` | `CharArrayReader` |
| `ByteArrayOutputStream` | `CharArrayWriter` |
| `BufferedInputStream` | `BufferedReader` |
| `BufferedOutputStream` | `BufferedWriter` |
| `DataInputStream` | `InputStreamReader` (字节→字符) |
| `DataOutputStream` | `OutputStreamWriter` (字符→字节) |

### 使用示例：

```java
// 字节流复制文件
try (InputStream in = new FileInputStream("source.txt");
     OutputStream out = new FileOutputStream("target.txt")) {
    byte[] buffer = new byte[1024];
    int bytesRead;
    while ((bytesRead = in.read(buffer)) != -1) {
        out.write(buffer, 0, bytesRead);
    }
}

// 字符流读取文件
try (BufferedReader reader = new BufferedReader(new FileReader("file.txt"))) {
    String line;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
}
```

## 2. 流式API (java.util.stream包)

Java 8引入的Stream API用于处理集合数据的函数式操作。

### 主要特点：
- 不是数据结构，不存储数据
- 不会修改源数据
- 惰性执行（终端操作时才执行）
- 可并行处理

### 核心接口：
- `Stream<T>`：通用流
- `IntStream`：原始int流
- `LongStream`：原始long流
- `DoubleStream`：原始double流

### 操作类型：
1. **中间操作**（返回Stream）：
   - `filter(Predicate)`：过滤
   - `map(Function)`：映射
   - `sorted()`：排序
   - `distinct()`：去重
   - `limit(long)`：限制数量

2. **终端操作**（返回非Stream结果）：
   - `forEach(Consumer)`：遍历
   - `collect(Collector)`：收集
   - `reduce()`：归约
   - `count()`：计数
   - `anyMatch()`/`allMatch()`/`noneMatch()`：匹配检查

### 使用示例：

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");

// 过滤并输出
names.stream()
     .filter(name -> name.length() > 4)
     .forEach(System.out::println);

// 映射并收集
List<Integer> nameLengths = names.stream()
                               .map(String::length)
                               .collect(Collectors.toList());

// 并行计算
long count = names.parallelStream()
                 .filter(name -> name.startsWith("A"))
                 .count();
```

## 两种流的区别

| 特性 | I/O流 | Stream API |
|------|-------|------------|
| 用途 | 数据输入输出 | 集合数据处理 |
| 包 | java.io, java.nio | java.util.stream |
| 引入时间 | Java 1.0 | Java 8 |
| 数据单位 | 字节/字符 | 对象/原始值 |
| 操作方式 | 顺序读取/写入 | 函数式操作链 |
| 并行支持 | 有限 | 内置支持 |

## 最佳实践

1. **I/O流**：
   - 总是使用try-with-resources确保资源关闭
   - 对大文件使用缓冲流(BufferedInputStream/Reader)
   - 考虑使用NIO（New I/O）提高性能

2. **Stream API**：
   - 避免在lambda中修改外部状态
   - 对于简单操作，传统循环可能更高效
   - 大数据集考虑使用parallelStream()

理解这两种流的概念和适用场景，可以帮助你更有效地处理Java中的各种数据操作需求。