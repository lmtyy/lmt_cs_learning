# 缓冲流常用方法详解

缓冲流是 Java I/O 系统中的高效工具，包括 `BufferedInputStream`、`BufferedOutputStream`、`BufferedReader` 和 `BufferedWriter`。下面我将详细说明它们的常用方法签名、返回值和使用方法。

## 1. BufferedInputStream

### 方法签名及使用

```java
// 构造方法
BufferedInputStream(InputStream in)
BufferedInputStream(InputStream in, int size)

// 读取单个字节
public int read() throws IOException
// 返回值：读取的字节(0-255)，到达流末尾返回-1
// 使用：
int byteData = bis.read();
if (byteData != -1) {
    // 处理字节
}

// 读取到字节数组
public int read(byte[] b) throws IOException
// 返回值：实际读取的字节数，到达流末尾返回-1
// 使用：
byte[] buffer = new byte[1024];
int bytesRead = bis.read(buffer);
if (bytesRead != -1) {
    // 处理buffer中0到bytesRead-1的数据
}

// 读取到字节数组的指定位置
public int read(byte[] b, int off, int len) throws IOException
// 返回值：实际读取的字节数，到达流末尾返回-1
// 使用：
byte[] buffer = new byte[2048];
int bytesRead = bis.read(buffer, 100, 512); // 从buffer[100]开始存，最多读512字节

// 跳过字节
public long skip(long n) throws IOException
// 返回值：实际跳过的字节数
// 使用：
long skipped = bis.skip(1024); // 尝试跳过1KB

// 标记位置
public void mark(int readlimit)
// 使用：
bis.mark(1024); // 标记当前位置，允许后续最多读取readlimit字节后仍能reset

// 重置到标记位置
public void reset() throws IOException
// 使用：
bis.reset(); // 返回到上次mark的位置

// 检查是否支持mark/reset
public boolean markSupported()
// 使用：
if (bis.markSupported()) {
    bis.mark(1024);
    // ...操作...
    bis.reset();
}

// 关闭流
public void close() throws IOException
// 使用：
bis.close();
```

## 2. BufferedOutputStream

### 方法签名及使用

```java
// 构造方法
BufferedOutputStream(OutputStream out)
BufferedOutputStream(OutputStream out, int size)

// 写入单个字节
public void write(int b) throws IOException
// 使用：
bos.write(65); // 写入'A'

// 写入字节数组
public void write(byte[] b) throws IOException
// 使用：
byte[] data = "Hello".getBytes();
bos.write(data);

// 写入字节数组的指定部分
public void write(byte[] b, int off, int len) throws IOException
// 使用：
byte[] data = "Hello World".getBytes();
bos.write(data, 6, 5); // 写入"World"

// 刷新缓冲区
public void flush() throws IOException
// 使用：
bos.flush(); // 强制将缓冲区内容写入底层流

// 关闭流
public void close() throws IOException
// 注意：close()会自动调用flush()
bos.close();
```

## 3. BufferedReader

### 方法签名及使用

```java
// 构造方法
BufferedReader(Reader in)
BufferedReader(Reader in, int sz)

// 读取单个字符
public int read() throws IOException
// 返回值：读取的字符(0-65535)，到达流末尾返回-1
// 使用：
int charData = br.read();
if (charData != -1) {
    char c = (char)charData;
    // 处理字符
}

// 读取到字符数组
public int read(char[] cbuf) throws IOException
// 返回值：实际读取的字符数，到达流末尾返回-1
// 使用：
char[] buffer = new char[1024];
int charsRead = br.read(buffer);
if (charsRead != -1) {
    String s = new String(buffer, 0, charsRead);
}

// 读取到字符数组的指定位置
public int read(char[] cbuf, int off, int len) throws IOException
// 使用：
char[] buffer = new char[2048];
int charsRead = br.read(buffer, 100, 512); // 从buffer[100]开始存，最多读512字符

// 读取一行
public String readLine() throws IOException
// 返回值：一行内容(不包含换行符)，到达流末尾返回null
// 使用：
String line;
while ((line = br.readLine()) != null) {
    // 处理行内容
}

// 跳过字符
public long skip(long n) throws IOException
// 使用：
long skipped = br.skip(100); // 尝试跳过100个字符

// 标记位置
public void mark(int readAheadLimit) throws IOException
// 使用：
br.mark(1024); // 标记当前位置

// 重置到标记位置
public void reset() throws IOException
// 使用：
br.reset(); // 返回到上次mark的位置

// 检查是否支持mark/reset
public boolean markSupported()
// 使用：
if (br.markSupported()) {
    br.mark(1024);
    // ...操作...
    br.reset();
}

// 关闭流
public void close() throws IOException
// 使用：
br.close();
```

## 4. BufferedWriter

### 方法签名及使用

```java
// 构造方法
BufferedWriter(Writer out)
BufferedWriter(Writer out, int sz)

// 写入单个字符
public void write(int c) throws IOException
// 使用：
bw.write('A'); // 写入字符'A'

// 写入字符数组
public void write(char[] cbuf) throws IOException
// 使用：
char[] data = {'H','e','l','l','o'};
bw.write(data);

// 写入字符数组的指定部分
public void write(char[] cbuf, int off, int len) throws IOException
// 使用：
char[] data = "Hello World".toCharArray();
bw.write(data, 6, 5); // 写入"World"

// 写入字符串
public void write(String s) throws IOException
// 使用：
bw.write("Hello");

// 写入字符串的指定部分
public void write(String s, int off, int len) throws IOException
// 使用：
bw.write("Hello World", 6, 5); // 写入"World"

// 写入换行符(跨平台)
public void newLine() throws IOException
// 使用：
bw.write("第一行");
bw.newLine(); // 换行
bw.write("第二行");

// 刷新缓冲区
public void flush() throws IOException
// 使用：
bw.flush(); // 强制将缓冲区内容写入底层流

// 关闭流
public void close() throws IOException
// 注意：close()会自动调用flush()
bw.close();
```

## 5. 缓冲流的通用最佳实践

1. **始终使用try-with-resources**：
   ```java
   try (BufferedReader br = new BufferedReader(new FileReader("file.txt"))) {
       // 使用br
   } // 自动关闭
   ```

2. **合理设置缓冲区大小**：
   ```java
   // 对于大文件处理，可增大缓冲区
   BufferedReader br = new BufferedReader(new FileReader("bigfile.txt"), 32768);
   ```

3. **及时处理异常**：
   ```java
   try {
       // 缓冲流操作
   } catch (IOException e) {
       e.printStackTrace();
       // 或更合适的错误处理
   }
   ```

4. **重要数据及时flush**：
   ```java
   bw.write("重要数据");
   bw.flush(); // 确保数据立即写入
   ```

5. **避免混合使用缓冲流和非缓冲流**：
   ```java
   // 不推荐这样混用
   BufferedInputStream bis = new BufferedInputStream(...);
   bis.read();
   someNonBufferedStream.read(); // 可能破坏缓冲逻辑
   ```

缓冲流通过减少实际的物理I/O操作次数，可以显著提高程序的I/O性能，特别是在处理大量数据时效果更为明显。理解并正确使用这些方法，可以让你编写出更高效的Java I/O代码。