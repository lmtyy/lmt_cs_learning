# Java泛型中T和通配符(?)的区别与使用场景

在Java泛型中，`T`（或其他类型参数如E、K、V等）和通配符`?`都用于表示未知类型，但它们有不同的用途和使用场景。理解它们的区别对于正确使用泛型非常重要。

## 1. 基本区别

| 特性        | 类型参数(T/E/K/V) | 通配符(?) |
|------------|------------------|----------|
| **声明位置** | 类/接口/方法声明处 | 方法参数/变量类型 |
| **可命名性** | 有具体名称(T等)   | 匿名(无名称) |
| **可引用性** | 可在类/方法内部使用 | 仅表示"某种类型" |
| **多重使用** | 可定义多个(T,K,V) | 只能单独使用 |

## 2. 何时使用类型参数(T/E/K/V)

### 适用场景：
- **定义泛型类/接口时**：
  ```java
  public class Box<T> {  // T在这里定义
      private T content;
      public void set(T content) { this.content = content; }
      public T get() { return content; }
  }
  ```

- **定义泛型方法时**：
  ```java
  public static <T> T getFirst(List<T> list) {  // T在这里定义
      return list.isEmpty() ? null : list.get(0);
  }
  ```

- **需要在代码中引用该类型时**：
  ```java
  public interface Pair<K, V> {  // 需要能引用键和值的类型
      K getKey();
      V getValue();
  }
  ```

### 特点：
- 有明确的名称(T、E、K、V等)
- 可以在整个类或方法中使用
- 可以用于声明变量、返回值类型等

## 3. 何时使用通配符(?)

### 适用场景：
- **方法参数只需要使用泛型容器，不关心具体类型时**：
  ```java
  public void printList(List<?> list) {  // 可以接受任何List
      for (Object elem : list) {
          System.out.println(elem);
      }
  }
  ```

- **需要灵活的类型关系(上界/下界)时**：
  ```java
  // 上界通配符 - 处理Number及其子类
  public double sum(List<? extends Number> numbers) {
      double sum = 0;
      for (Number num : numbers) {
          sum += num.doubleValue();
      }
      return sum;
  }
  
  // 下界通配符 - 可以添加Integer到Integer或其父类的集合
  public void addIntegers(List<? super Integer> list) {
      list.add(1);
      list.add(2);
  }
  ```

- **变量声明时类型不确定但有限制时**：
  ```java
  List<? extends Number> numbers = new ArrayList<Integer>();
  ```

### 特点：
- 没有具体名称
- 只能表示"某种类型"或"某种类型的子/父类"
- 不能用于定义泛型类或方法
- 不能直接用于声明变量类型(除非是参数或字段)

## 4. 关键区别示例

### 示例1：定义vs使用
```java
// 定义泛型类 - 必须用T
public class Holder<T> { /* ... */ }

// 使用泛型类 - 可以用具体类型或?
Holder<String> stringHolder;  // 具体类型
Holder<?> unknownHolder;     // 未知类型
```

### 示例2：方法参数中的选择
```java
// 使用类型参数 - 当方法需要知道并操作该类型时
public static <T> void addAll(List<T> dest, List<T> src) {
    dest.addAll(src);
}

// 使用通配符 - 当方法只需要使用容器而不操作具体类型时
public static void printAll(List<?> list) {
    for (Object o : list) System.out.println(o);
}
```

### 示例3：上界限制
```java
// 使用类型参数的上界 - 当需要返回该类型时
public static <T extends Number> T max(T a, T b) {
    return a.doubleValue() > b.doubleValue() ? a : b;
}

// 使用通配符的上界 - 当只需要消费该类型时
public static void processNumbers(List<? extends Number> numbers) {
    for (Number n : numbers) {
        System.out.println(n.doubleValue());
    }
}
```

## 5. 经验法则

1. **定义泛型结构(类/接口/方法)时** → 用`T`/`E`/`K`/`V`等类型参数
2. **使用泛型结构但不需要知道具体类型时** → 用`?`通配符
3. **需要指定类型关系(子类/父类)但不操作具体类型时** → 用`? extends/super`
4. **需要在代码中引用该类型时** → 必须用类型参数

记住：类型参数(T)是"我有一种类型，我称它为T"，而通配符(?)是"我不知道也不关心具体是什么类型"。