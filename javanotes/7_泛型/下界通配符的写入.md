# 下界通配符(`? super T`)添加元素的深入解释

你提出了一个很好的问题。确实，`List<? super Apple>`表示"可以存放Apple或其父类的List"，但为什么我们可以添加Apple的**子类**呢？这看起来似乎有些矛盾，但实际上这是类型安全的，我来详细解释。

## 基本概念回顾

`? super Apple`表示"Apple或Apple的任意父类型"。所以它可以匹配：
- `List<Apple>`
- `List<Fruit>` (如果Apple extends Fruit)
- `List<Object>`

## 为什么可以添加Apple的子类

关键在于Java的**多态性**和**里氏替换原则**(LSP)。子类对象可以替代父类对象使用。

### 示例分析

```java
List<? super Apple> list = new ArrayList<Fruit>();

// 可以添加Apple及其子类
list.add(new Apple());      // 允许
list.add(new RedApple());   // 允许(假设RedApple extends Apple)
```

### 为什么这是安全的

1. **对于`List<Apple>`**：
   - 可以添加Apple和任何Apple的子类(这是正常的多态行为)

2. **对于`List<Fruit>`**：
   - Apple是Fruit的子类，所以可以添加Apple
   - RedApple也是Fruit的"孙子类"，自然可以添加

3. **对于`List<Object>`**：
   - 任何对象都是Object的子类，当然可以添加

### 为什么不能添加Apple的父类

```java
list.add(new Fruit());  // 编译错误！
```

因为：
- 如果list实际上是`List<Apple>`，添加Fruit会破坏类型安全
- 编译器不知道list具体是`List<Apple>`、`List<Fruit>`还是`List<Object>`，所以只能保证最严格的情况(`List<Apple>`)

## 子类添加的数学解释

从类型理论看，如果`S <: T`(S是T的子类型)，那么：
- `List<? super T>`可以接受任何`T`或`T`的子类型(`S`)的元素
- 因为`S <: T`，而容器可以接受`T`，自然也可以接受所有`S`

## 实际应用场景

这种特性在需要"消费"对象的场景非常有用，比如：

```java
// 将多个Apple放入一个集合
public static void addApples(List<? super Apple> list) {
    list.add(new Apple());
    list.add(new RedApple());
    list.add(new GreenApple());
}
```

这个方法可以接受：
- `List<Apple>`
- `List<Fruit>`
- `List<Object>`

但保证只能添加Apple及其子类的对象。

## 总结

`? super Apple`的写入规则是：
- **可以添加**：Apple及其所有子类(因为无论实际的父类是什么，Apple及其子类都能向上转型匹配)
- **不能添加**：Apple的父类(因为无法确定具体是哪个父类)
- **读取限制**：只能作为Object读取(因为无法确定具体是哪个父类)

这种设计完美平衡了类型安全性和灵活性。