# Java泛型通配符的读取和写入限制详解

理解泛型通配符(`? extends`和`? super`)的读取写入限制是掌握Java泛型的关键。我来详细解释为什么会有这些限制。

## 1. 上界通配符 `? extends T` (生产者，协变)

```java
List<? extends Fruit> fruits = new ArrayList<Apple>();
```

### 读取限制：
✅ **可以安全读取为Fruit类型**：
```java
Fruit fruit = fruits.get(0);  // 安全，因为无论实际是Apple还是Orange，都是Fruit
```

### 写入限制：
❌ **不能添加任何元素（除了null）**：
```java
fruits.add(new Apple());  // 编译错误！
fruits.add(new Orange()); // 编译错误！
fruits.add(new Fruit());  // 编译错误！
fruits.add(null);         // 唯一允许的写入
```

### 为什么？
因为编译器不知道`fruits`实际指向的是`List<Apple>`还是`List<Orange>`。如果允许添加`Apple`，但实际是`List<Orange>`就会破坏类型安全。反之亦然。唯一安全的是`null`，因为它可以赋给任何引用类型。

## 2. 下界通配符 `? super T` (消费者，逆变)

```java
List<? super Apple> apples = new ArrayList<Fruit>();
```

### 写入限制：
✅ **可以安全添加Apple及其子类**：
```java
apples.add(new Apple());     // 允许
apples.add(new RedApple());  // 允许(假设RedApple extends Apple)
```

❌ **不能添加Fruit或其他不相关类型**：
```java
apples.add(new Fruit());    // 编译错误！
apples.add(new Orange());   // 编译错误！
```

### 读取限制：
❌ **只能作为Object读取**：
```java
Object obj = apples.get(0);  // 唯一安全的读取方式
Apple apple = apples.get(0); // 编译错误！
```

### 为什么？
因为`List<? super Apple>`可能是`List<Apple>`、`List<Fruit>`甚至`List<Object>`。编译器无法确定取出的元素具体是什么类型，唯一确定的是它至少是`Object`。

## PECS原则总结

- **Producer-Extends**：如果你只是从一个泛型集合中**取出**元素(生产元素)，使用`? extends T`
- **Consumer-Super**：如果你只是向一个泛型集合中**放入**元素(消费元素)，使用`? super T`
- **既取又存**：如果你既要存又要取，就不要使用通配符，直接用确切类型

## 现实例子

```java
// 复制方法使用PECS原则
public static <T> void copy(List<? super T> dest, List<? extends T> src) {
    for (int i = 0; i < src.size(); i++) {
        dest.add(src.get(i));  // 从生产者(src)读取，向消费者(dest)写入
    }
}
```

这种设计确保了最大程度的类型安全，同时提供了必要的灵活性。