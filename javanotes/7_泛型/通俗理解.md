# Java泛型通俗详解

## 泛型是什么？

想象你有一个盒子，泛型就是给这个盒子贴上一个标签，说明这个盒子专门用来装什么类型的东西。

- 没有泛型：盒子可以装任何东西，但每次取出时你需要自己判断是什么
- 有泛型：盒子明确标注"只能装书"，这样你放东西和取东西时都很明确

## 为什么要用泛型？

### 问题示例（没有泛型时）

```java
List list = new ArrayList();
list.add("hello");
list.add(123);  // 可以放任何类型

// 取数据时
String str = (String) list.get(0);  // 需要强制转换
Integer num = (Integer) list.get(1); // 需要强制转换
```

这样会有两个问题：
1. 可能放错类型（比如不小心放了数字到字符串列表）
2. 每次取数据都要强制转换，很麻烦

### 使用泛型后

```java
List<String> stringList = new ArrayList<>();
stringList.add("hello");
// stringList.add(123);  // 编译错误！只能放String

String str = stringList.get(0);  // 不需要强制转换
```

## 泛型的实际应用场景

### 1. 集合类（最常用）

```java
// 定义只能存放String的列表
List<String> names = new ArrayList<>();
names.add("张三");
names.add("李四");

// 定义键为String，值为Integer的Map
Map<String, Integer> scores = new HashMap<>();
scores.put("数学", 90);
scores.put("语文", 85);
```

### 2. 自定义泛型类

```java
// 定义一个通用的"箱子"类
public class Box<T> {
    private T content;
    
    public void put(T thing) {
        this.content = thing;
    }
    
    public T get() {
        return content;
    }
}

// 使用
Box<String> stringBox = new Box<>();
stringBox.put("秘密文件");
String file = stringBox.get();  // 直接得到String

Box<Integer> intBox = new Box<>();
intBox.put(100);
int num = intBox.get();  // 直接得到int
```

### 3. 泛型方法

```java
// 一个比较两个对象是否相同的方法
public static <T> boolean isEqual(T a, T b) {
    return a.equals(b);
}

// 使用
boolean result1 = isEqual("hello", "world");  // 比较字符串
boolean result2 = isEqual(10, 10);  // 比较整数
```

## 通配符的使用场景

### 1. 上界通配符 <? extends T>

```java
// 处理各种数字列表的方法
public static double sum(List<? extends Number> list) {
    double sum = 0;
    for (Number num : list) {
        sum += num.doubleValue();
    }
    return sum;
}

// 可以传入List<Integer>, List<Double>等
List<Integer> ints = Arrays.asList(1, 2, 3);
sum(ints);  // 6.0
```

### 2. 下界通配符 <? super T>

```java
// 向列表中添加一系列数字
public static void addNumbers(List<? super Integer> list) {
    for (int i = 1; i <= 10; i++) {
        list.add(i);
    }
}

// 可以传入List<Integer>, List<Number>, List<Object>
List<Number> numbers = new ArrayList<>();
addNumbers(numbers);
```

## 实际开发中的经验

1. **集合类一定要用泛型**：这是泛型最常用的地方
   ```java
   // 好
   List<String> list = new ArrayList<>();
   
   // 不好（原始类型）
   List list = new ArrayList();
   ```

2. **当方法需要处理多种类型时考虑泛型方法**
   ```java
   public static <T> T getFirst(List<T> list) {
       return list.get(0);
   }
   ```

3. **不确定具体类型但知道范围时用通配符**
   ```java
   // 处理任何Animal及其子类的列表
   void processAnimals(List<? extends Animal> animals)
   ```

4. **避免过度使用泛型**：只有在真正需要灵活处理多种类型时才用

记住：泛型的核心目的是让代码更安全（编译时检查类型）和更清晰（减少强制转换）。刚开始可能会觉得复杂，但随着使用会越来越自然。