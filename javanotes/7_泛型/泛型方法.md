# Java泛型方法深度解析

泛型方法是Java泛型中非常强大的特性，它允许在方法级别上使用类型参数，而不是在整个类上使用。下面我将全面详细地讲解泛型方法。

## 1. 基本语法

泛型方法的基本语法结构如下：

```java
[访问修饰符] <类型参数列表> 返回值类型 方法名([参数列表]) {
    // 方法体
}
```

- **类型参数列表**：用尖括号`<>`括起来，可以包含一个或多个类型参数（如`<T>`、`<T, U>`等）
- **类型参数**：通常用单个大写字母表示（如T、E、K、V等）

### 简单示例

```java
public class GenericMethodDemo {
    // 泛型方法示例
    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.print(element + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Integer[] intArray = {1, 2, 3, 4, 5};
        String[] stringArray = {"Hello", "World"};
        
        printArray(intArray);    // 输出: 1 2 3 4 5 
        printArray(stringArray); // 输出: Hello World 
    }
}
```

## 2. 泛型方法的类型推断

Java编译器可以自动推断泛型方法的具体类型参数，通常不需要显式指定：

```java
// 调用时可以不指定类型参数
printArray(intArray);    // 编译器推断T为Integer
printArray(stringArray); // 编译器推断T为String

// 也可以显式指定类型参数
GenericMethodDemo.<Integer>printArray(intArray);
GenericMethodDemo.<String>printArray(stringArray);
```

## 3. 有返回值的泛型方法

泛型方法可以有返回值，返回类型可以是类型参数或包含类型参数：

```java
public static <T> T getMiddle(T[] array) {
    return array[array.length / 2];
}

// 使用
String[] names = {"John", "Mary", "David"};
String middle = getMiddle(names);  // 返回"Mary"
```

## 4. 多类型参数的泛型方法

一个泛型方法可以定义多个类型参数：

```java
public static <K, V> void printPair(K key, V value) {
    System.out.println(key + " = " + value);
}

// 使用
printPair("Age", 25);  // 输出: Age = 25
```

## 5. 受限类型参数

可以对类型参数设置边界限制：

### 上界限制（extends）

```java
public static <T extends Number> double sum(T num1, T num2) {
    return num1.doubleValue() + num2.doubleValue();
}

// 使用
double result = sum(10, 20.5);  // 30.5
```

### 多重边界

```java
public static <T extends Number & Comparable<T>> T max(T a, T b) {
    return a.compareTo(b) > 0 ? a : b;
}

// 使用
Integer bigger = max(10, 20);  // 20
```

## 6. 泛型方法与可变参数

泛型方法可以与可变参数(varargs)结合使用：

```java
public static <T> List<T> makeList(T... args) {
    List<T> result = new ArrayList<>();
    for (T item : args) {
        result.add(item);
    }
    return result;
}

// 使用
List<String> strings = makeList("A", "B", "C");
List<Integer> ints = makeList(1, 2, 3);
```

## 7. 泛型静态方法

泛型方法经常被定义为静态方法，因为它们不依赖于类的类型参数：

```java
public class ArrayUtils {
    public static <T> void swap(T[] array, int i, int j) {
        T temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}

// 使用
String[] words = {"Hello", "World"};
ArrayUtils.swap(words, 0, 1);  // words变为["World", "Hello"]
```

## 8. 泛型方法与通配符的对比

### 泛型方法

```java
// 可以返回T类型
public static <T> T getFirst(List<T> list) {
    return list.get(0);
}
```

### 使用通配符的方法

```java
// 只能返回Object，因为不知道具体类型
public static Object getFirstWildcard(List<?> list) {
    return list.get(0);
}
```

## 9. 实际应用案例

### 案例1：集合工具方法

```java
public static <T> void copy(List<? super T> dest, List<? extends T> src) {
    for (int i = 0; i < src.size(); i++) {
        dest.set(i, src.get(i));
    }
}
```

### 案例2：工厂方法

```java
public static <T> List<T> createEmptyList() {
    return new ArrayList<T>();
}

// 使用
List<String> stringList = createEmptyList();
```

### 案例3：条件过滤

```java
public static <T> List<T> filter(List<T> list, Predicate<T> predicate) {
    List<T> result = new ArrayList<>();
    for (T item : list) {
        if (predicate.test(item)) {
            result.add(item);
        }
    }
    return result;
}

// 使用
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> evens = filter(numbers, n -> n % 2 == 0);
```

## 10. 注意事项

1. **不能创建类型参数的实例**：
   ```java
   public static <T> void wrongMethod() {
       T obj = new T();  // 编译错误
   }
   ```

2. **不能创建泛型数组**：
   ```java
   public static <T> void anotherWrongMethod() {
       T[] array = new T[10];  // 编译错误
   }
   ```

3. **静态上下文中的限制**：
   - 类的静态方法不能使用类的类型参数
   - 静态方法必须声明自己的类型参数

4. **原始类型警告**：
   ```java
   List list = new ArrayList();  // 原始类型，不安全
   List<String> safeList = new ArrayList<>();  // 推荐写法
   ```

泛型方法是Java泛型中非常灵活和强大的工具，合理使用可以大大提高代码的复用性和类型安全性。理解并掌握泛型方法对于编写高质量的Java代码非常重要。