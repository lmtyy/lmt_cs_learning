# Java 检查型异常(Checked Exception)与非检查型异常(Unchecked Exception)详解

## 一、基本概念区分

Java 异常分为两大类：

1. **检查型异常(Checked Exception)**
   - 继承自 `Exception` 但不继承 `RuntimeException`
   - 编译器强制要求处理（必须捕获或声明抛出）
   - 通常表示程序外部因素导致的、可预期的异常情况

2. **非检查型异常(Unchecked Exception)**
   - 继承自 `RuntimeException` 或 `Error`
   - 编译器不强制要求处理
   - 通常表示程序逻辑错误或系统级问题

## 二、检查型异常详解

### 特点：
- **编译时检查**：编译器会验证是否处理了这些异常
- **必须处理**：要么用 try-catch 捕获，要么用 throws 声明
- **可恢复性**：通常表示可以恢复的问题

### 常见检查型异常：
- `IOException` 及其子类
  - `FileNotFoundException`
  - `EOFException`
- `SQLException`
- `ClassNotFoundException`
- `InterruptedException`

### 处理方式示例：

```java
// 方式1：捕获处理
try {
    FileInputStream fis = new FileInputStream("test.txt");
} catch (FileNotFoundException e) {
    System.out.println("文件未找到: " + e.getMessage());
}

// 方式2：声明抛出
public void readFile() throws FileNotFoundException {
    FileInputStream fis = new FileInputStream("test.txt");
}
```

## 三、非检查型异常详解

### 特点：
- **运行时出现**：编译时不会检查
- **不强制处理**：可以处理，但不是必须的
- **通常不可恢复**：多数表示程序bug或系统资源问题

### 两类非检查型异常：
1. **RuntimeException 及其子类**
   - `NullPointerException`
   - `ArrayIndexOutOfBoundsException`
   - `IllegalArgumentException`
   - `ClassCastException`

2. **Error 及其子类**
   - `OutOfMemoryError`
   - `StackOverflowError`
   - `NoClassDefFoundError`

### 典型场景示例：

```java
// 1. 空指针异常
String str = null;
System.out.println(str.length()); // NullPointerException

// 2. 数组越界
int[] arr = new int[3];
System.out.println(arr[5]); // ArrayIndexOutOfBoundsException

// 3. 类型转换异常
Object obj = "hello";
Integer num = (Integer) obj; // ClassCastException
```

## 四、关键区别对比

| 特性                | 检查型异常                      | 非检查型异常                      |
|---------------------|-------------------------------|----------------------------------|
| **继承关系**         | Exception 的直接子类          | RuntimeException 或 Error 的子类 |
| **编译检查**         | 是                            | 否                               |
| **处理要求**         | 必须捕获或声明                 | 可选处理                         |
| **产生原因**         | 外部条件导致                   | 程序逻辑错误或系统问题            |
| **恢复可能性**       | 通常可恢复                    | 通常不可恢复                     |
| **设计意图**         | 强制处理已知可能的问题          | 处理编程错误和严重问题            |

## 五、设计选择原则

### 何时使用检查型异常：
1. 调用者能够且应该处理的异常情况
2. 可预见的、可恢复的问题
3. 如I/O操作、数据库访问等外部依赖操作

### 何时使用非检查型异常：
1. 程序逻辑错误（如空指针、数组越界）
2. 不可恢复的系统错误
3. 参数校验失败等情况
4. 当异常表示编程错误而非特殊情况时

### 自定义异常的选择：
```java
// 检查型异常示例（需要调用者处理）
public class InvalidConfigException extends Exception {
    public InvalidConfigException(String message) {
        super(message);
    }
}

// 非检查型异常示例（参数校验失败）
public class InvalidInputException extends RuntimeException {
    public InvalidInputException(String message) {
        super(message);
    }
}
```

## 六、最佳实践

1. **不要滥用检查型异常**：对于真正不可恢复的情况，使用非检查型异常
2. **避免捕获RuntimeException**：应该修复代码而不是捕获空指针等异常
3. **合理包装异常**：底层异常可以包装为高层业务异常
4. **保持异常信息明确**：提供有意义的错误消息
5. **考虑异常性能**：创建异常对象开销较大，避免在正常流程中使用

理解这两种异常的区别和适用场景，可以帮助你设计更健壮的API和更合理的错误处理机制。