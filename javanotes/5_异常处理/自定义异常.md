# Java 自定义异常的实现方式

在 Java 中，你可以通过继承现有的异常类来创建自定义异常。以下是实现自定义异常的完整方式：

## 1. 基本自定义异常实现

### 检查型异常 (Checked Exception)
继承 `Exception` 类：

```java
// 必须处理或在方法签名中声明抛出
public class MyCheckedException extends Exception {
    // 无参构造
    public MyCheckedException() {
        super();
    }
    
    // 带错误信息的构造
    public MyCheckedException(String message) {
        super(message);
    }
    
    // 带错误信息和原因的构造
    public MyCheckedException(String message, Throwable cause) {
        super(message, cause);
    }
    
    // 带原因的构造
    public MyCheckedException(Throwable cause) {
        super(cause);
    }
}
```

### 非检查型异常 (Unchecked Exception)
继承 `RuntimeException` 类：

```java
// 不需要在方法签名中声明
public class MyUncheckedException extends RuntimeException {
    // 同上可以定义多个构造方法
    public MyUncheckedException(String message) {
        super(message);
    }
}
```

## 2. 自定义异常的最佳实践

1. **命名规范**：以 "Exception" 结尾，如 `InvalidUserInputException`
2. **提供有用的构造方法**：至少提供带 String 参数的构造方法
3. **添加业务相关属性**：

```java
public class PaymentException extends Exception {
    private final String transactionId;
    private final BigDecimal amount;
    
    public PaymentException(String message, String transactionId, BigDecimal amount) {
        super(message);
        this.transactionId = transactionId;
        this.amount = amount;
    }
    
    // getter 方法
    public String getTransactionId() {
        return transactionId;
    }
    
    public BigDecimal getAmount() {
        return amount;
    }
}
```

## 3. 使用自定义异常

### 抛出自定义异常

```java
public void processOrder(Order order) throws OrderProcessingException {
    if (order == null) {
        throw new OrderProcessingException("订单不能为null");
    }
    
    if (order.getItems().isEmpty()) {
        throw new OrderProcessingException("订单必须包含至少一件商品", order.getId());
    }
}
```

### 捕获自定义异常

```java
try {
    orderService.processOrder(order);
} catch (OrderProcessingException e) {
    logger.error("订单处理失败: {}, 订单ID: {}", e.getMessage(), e.getOrderId());
    // 其他处理逻辑
}
```

## 4. 自定义异常的高级用法

### 异常链（包装原始异常）

```java
try {
    // 某些可能抛出SQLException的操作
} catch (SQLException e) {
    throw new DataAccessException("数据库访问失败", e); // 保留原始异常
}
```

### 异常枚举类型

```java
public enum ErrorCode {
    INVALID_INPUT(1001, "无效输入"),
    RESOURCE_NOT_FOUND(1002, "资源未找到"),
    ACCESS_DENIED(1003, "访问被拒绝");
    
    private final int code;
    private final String message;
    
    // 构造方法、getter等
}

public class BusinessException extends RuntimeException {
    private final ErrorCode errorCode;
    
    public BusinessException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.errorCode = errorCode;
    }
    
    // getter方法
}
```

## 5. 为什么要使用自定义异常

1. **更精确的错误分类**：比使用标准异常更能表达业务错误
2. **携带更多上下文信息**：可以包含业务相关的额外数据
3. **更好的错误处理**：调用方可以根据异常类型采取不同措施
4. **提高代码可读性**：异常名称直接反映问题本质

## 6. 实际应用示例

```java
// 自定义异常
public class InsufficientBalanceException extends RuntimeException {
    private final String accountId;
    private final BigDecimal currentBalance;
    private final BigDecimal requiredAmount;
    
    public InsufficientBalanceException(String accountId, 
                                      BigDecimal currentBalance, 
                                      BigDecimal requiredAmount) {
        super(String.format("账户 %s 余额不足 (当前: %s, 需要: %s)", 
              accountId, currentBalance, requiredAmount));
        this.accountId = accountId;
        this.currentBalance = currentBalance;
        this.requiredAmount = requiredAmount;
    }
    
    // getter方法
}

// 使用场景
public void withdraw(String accountId, BigDecimal amount) {
    BigDecimal balance = getBalance(accountId);
    if (balance.compareTo(amount) < 0) {
        throw new InsufficientBalanceException(accountId, balance, amount);
    }
    // 执行扣款操作
}
```

通过自定义异常，你可以创建更符合业务需求的错误处理机制，使你的代码更加健壮和易于维护。