# Java程序异常处理机制

在Java中，异常是否会导致程序立即终止取决于**异常类型**和**是否被捕获处理**。以下是详细说明：

## 一、未捕获异常的情况

### 1. 未检查异常（RuntimeException及其子类）
```java
public class Example {
    public static void main(String[] args) {
        int[] arr = new int[3];
        System.out.println(arr[5]); // ArrayIndexOutOfBoundsException
        System.out.println("这行不会执行"); // 程序在此处终止
    }
}
```
- ❌ **会立即终止**：异常会沿着调用栈向上传播
- 🔥 **最终效果**：如果传播到main方法仍未被捕获，线程终止

### 2. 检查异常（非RuntimeException）
```java
public class Example {
    public static void main(String[] args) {
        FileInputStream fis = new FileInputStream("nonexist.txt"); // 编译错误
        // 必须处理或声明throws
    }
}
```
- ⚠️ **编译时强制要求**：必须捕获或声明throws，否则无法编译

## 二、已捕获异常的情况

### 1. 正常捕获处理
```java
try {
    int result = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("捕获到异常: " + e.getMessage());
}
System.out.println("程序继续执行"); // 会执行
```
- ✅ **继续运行**：异常被捕获后程序继续执行catch块之后的代码

### 2. finally块保证执行
```java
try {
    riskyOperation();
} finally {
    System.out.println("无论是否异常都会执行");
}
```

## 三、特殊终止情况

### 1. 调用System.exit()
```java
try {
    System.exit(0); // 立即终止JVM
} finally {
    System.out.println("这行不会执行");
}
```

### 2. 致命错误（Error）
```java
public class Example {
    public static void main(String[] args) {
        throw new OutOfMemoryError(); // 通常会导致JVM终止
    }
}
```

## 四、多线程环境

- 单个线程异常不会影响其他线程
```java
new Thread(() -> {
    throw new RuntimeException("线程异常");
}).start();
System.out.println("主线程继续运行"); // 会执行
```

## 最佳实践建议

1. **防御性编程**：
   ```java
   if (divisor != 0) {
       result = dividend / divisor;
   }
   ```

2. **合理使用try-catch**：
   ```java
   try {
       // 可能出错的代码
   } catch (SpecificException e) {
       // 针对性处理
   } catch (Exception e) {
       // 兜底处理
   }
   ```

3. **记录异常信息**：
   ```java
   catch (IOException e) {
       logger.error("文件操作失败", e);
       throw new BusinessException("处理失败", e);
   }
   ```

总结：Java程序**只有未捕获的异常**才会导致当前线程终止，合理处理异常可以保证程序健壮性。