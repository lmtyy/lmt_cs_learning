
# **Java 接口（Interface）核心知识点详解**

接口（Interface）是 Java 中用于定义 **行为契约** 的关键机制，它提供了一种 **完全抽象** 的类型，允许类实现多继承行为。以下是接口的核心知识点：

---

## **1. 接口的基本定义**
- **接口使用 `interface` 关键字声明**，不能实例化。
- **默认所有方法都是 `public abstract`**（Java 8 之前）。
- **默认所有变量都是 `public static final`**（常量）。

**语法示例**：
```java
public interface Flyable {
    void fly();  // 默认是 public abstract
    int MAX_SPEED = 1000;  // 默认是 public static final
}
```

---

## **2. 接口的核心特性**
### **(1) 抽象方法（Java 8 之前）**
- **所有方法默认是 `public abstract`**，不能有方法体。
- **实现类必须覆盖所有抽象方法**（除非实现类也是 `abstract`）。

**示例**：
```java
interface Animal {
    void eat();  // 抽象方法
}

class Dog implements Animal {
    @Override
    public void eat() {  // 必须实现
        System.out.println("Dog is eating.");
    }
}
```

---

### **(2) 默认方法（Java 8+）**
- **使用 `default` 关键字**，提供默认实现，子类可选择是否覆盖。
- **主要用于接口升级**，避免破坏已有实现类。

**示例**：
```java
interface Vehicle {
    default void start() {  // 默认方法
        System.out.println("Vehicle started.");
    }
}

class Car implements Vehicle { }  // 可以不覆盖 start()

class Bike implements Vehicle {
    @Override
    public void start() {  // 可选择覆盖
        System.out.println("Bike started.");
    }
}
```

---

### **(3) 静态方法（Java 8+）**
- **使用 `static` 关键字**，属于接口本身，不能被子类继承或覆盖。
- **通过接口名直接调用**（如 `Flyable.takeOff()`）。

**示例**：
```java
interface MathUtils {
    static int add(int a, int b) {  // 静态方法
        return a + b;
    }
}

// 调用方式：
int result = MathUtils.add(5, 3);  // 输出 8
```

---

### **(4) 私有方法（Java 9+）**
- **使用 `private` 关键字**，仅限接口内部使用，用于代码复用。
- 分为：
  - `private` 方法（普通私有方法）
  - `private static` 方法（静态私有方法）

**示例**：
```java
interface Logger {
    default void logInfo(String message) {
        log("[INFO]", message);
    }

    default void logError(String message) {
        log("[ERROR]", message);
    }

    private void log(String level, String message) {  // 私有方法
        System.out.println(level + " " + message);
    }
}
```

---

## **3. 接口 vs 抽象类**
| **特性**               | **接口（Interface）**          | **抽象类（Abstract Class）**  |
|-----------------------|-------------------------------|-----------------------------|
| **方法实现**           | Java 8+ 支持 `default`/`static` | 可以包含具体方法和抽象方法     |
| **变量**              | 只能是 `public static final`   | 可以是任意修饰符（实例变量）  |
| **继承机制**          | 支持多继承（`implements A, B`）| 单继承（`extends` 仅一个）   |
| **构造方法**          | 不能有                        | 可以有                      |
| **设计目的**          | 定义“行为契约”（能做什么）      | 定义“是什么”（is-a 关系）    |

---

## **4. 接口的应用场景**
### **(1) 多继承（实现多个接口）**
```java
interface Flyable {
    void fly();
}

interface Swimmable {
    void swim();
}

class Duck implements Flyable, Swimmable {  // 多继承
    @Override
    public void fly() { ... }

    @Override
    public void swim() { ... }
}
```

### **(2) 回调机制（如事件监听）**
```java
interface OnClickListener {
    void onClick();
}

class Button {
    private OnClickListener listener;

    public void setOnClickListener(OnClickListener listener) {
        this.listener = listener;
    }

    public void click() {
        if (listener != null) {
            listener.onClick();  // 回调
        }
    }
}
```

### **(3) 函数式编程（Lambda 表达式）**
```java
interface Calculator {
    int compute(int a, int b);
}

// Lambda 实现
Calculator add = (a, b) -> a + b;
Calculator multiply = (a, b) -> a * b;

System.out.println(add.compute(2, 3));  // 5
```

---

## **5. 接口的继承**
- **接口可以继承多个接口**（`extends A, B`）。
- **类实现接口时，必须实现所有未实现的抽象方法**（包括父接口的）。

**示例**：
```java
interface A {
    void methodA();
}

interface B extends A {
    void methodB();
}

class MyClass implements B {
    @Override
    public void methodA() { ... }  // 必须实现 A 的方法

    @Override
    public void methodB() { ... }  // 必须实现 B 的方法
}
```

---

## **6. 接口的最佳实践**
1. **优先使用接口**（除非需要共享代码，再用抽象类）。
2. **避免过度设计**（不要定义太多小接口）。
3. **合理使用 `default` 方法**（避免破坏已有实现）。
4. **接口命名通常用 `-able` 后缀**（如 `Runnable`, `Comparable`）。

---

## **总结**
- **接口定义行为契约**，支持多继承，适合“能做什么”场景。
- **Java 8+ 支持 `default`/`static`/`private` 方法**，增强灵活性。
- **优先使用接口**，抽象类用于代码复用。

掌握接口的使用，能让你写出更灵活、可扩展的代码！ 🚀