# Java继承知识点总结

继承是Java面向对象编程的三大特性之一（封装、继承、多态），它允许一个类（子类）继承另一个类（父类）的属性和方法。

## 基本概念

1. **extends关键字**：用于建立继承关系
   ```java
   class ChildClass extends ParentClass {
       // 子类特有属性和方法
   }
   ```

2. **单继承**：Java只支持单继承，一个类只能直接继承一个父类

3. **继承的内容**：
   - 可以继承父类的public和protected成员
   - 可以继承默认访问修饰的成员（如果在同一包中）
   - 不能继承private成员
   - 不能继承构造方法

## 方法重写(Override)

1. **规则**：
   - 方法名、参数列表必须相同
   - 返回类型可以相同或是父类返回类型的子类
   - 访问权限不能比父类更严格
   - 不能抛出比父类更宽泛的异常

2. **@Override注解**：推荐使用，帮助编译器检查是否正确重写

3. **示例**：
   ```java
   class Animal {
       public void makeSound() {
           System.out.println("Animal sound");
       }
   }
   
   class Dog extends Animal {
       @Override
       public void makeSound() {
           System.out.println("Bark");
       }
   }
   ```

## super关键字

1. **调用父类构造方法**：
   ```java
   public ChildClass() {
       super(); // 调用父类无参构造，可省略
   }
   ```

2. **调用父类方法**：
   ```java
   super.parentMethod();
   ```

3. **访问父类属性**：
   ```java
   super.parentField;
   ```

## 构造方法继承

1. 子类构造方法必须先调用父类构造方法
2. 如果没有显式调用，编译器会自动插入`super()`
3. 如果父类没有无参构造，子类必须显式调用父类的有参构造

## 继承中的初始化顺序

1. 父类静态代码块和静态变量
2. 子类静态代码块和静态变量
3. 父类实例变量和普通代码块
4. 父类构造方法
5. 子类实例变量和普通代码块
6. 子类构造方法

## 阻止继承

1. **final类**：不能被继承
   ```java
   public final class FinalClass {}
   ```

2. **final方法**：不能被子类重写
   ```java
   public final void finalMethod() {}
   ```

## Object类

1. 所有类的直接或间接父类
2. 重要方法：
   - `toString()`
   - `equals()`
   - `hashCode()`
   - `getClass()`
   - `clone()`
   - `finalize()`

## 抽象类和继承

1. 抽象类可以包含抽象方法和具体方法
2. 子类必须实现所有抽象方法，除非子类也是抽象类
   ```java
   abstract class Animal {
       abstract void makeSound();
   }
   
   class Dog extends Animal {
       @Override
       void makeSound() {
           System.out.println("Bark");
       }
   }
   ```

## 接口与继承

1. 类可以实现多个接口
2. 接口可以继承多个接口
3. Java 8后接口可以有默认方法和静态方法

## 继承的优缺点

**优点**：
- 代码复用
- 易于维护和扩展
- 实现多态

**缺点**：
- 增加耦合度
- 可能破坏封装性
- 过度使用会导致类层次复杂

## 继承与组合的选择

1. **优先使用组合**：除非有明显的"is-a"关系
2. **继承适用于**：
   - 子类确实是父类的特殊类型
   - 需要多态行为
   - 需要重写父类方法

理解继承是掌握Java面向对象编程的关键，合理使用继承能提高代码的可维护性和扩展性。