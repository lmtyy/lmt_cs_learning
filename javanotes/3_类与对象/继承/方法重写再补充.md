# 重写父类private方法的影响

在Java中，当你尝试"重写"父类的private方法时，实际上并不会发生真正的重写(Override)，而是创建了一个**全新的方法**。这是因为private方法的可见性限制决定了子类根本"看不到"父类的private方法。

## 1. 实际会发生的情况

### 示例代码
```java
class Parent {
    private void privateMethod() {
        System.out.println("Parent的private方法");
    }
    
    public void callPrivate() {
        privateMethod();  // 父类自己调用private方法
    }
}

class Child extends Parent {
    // 这看起来像是"重写"，但实际上不是
    private void privateMethod() {
        System.out.println("Child的private方法");
    }
    
    public void callChildPrivate() {
        privateMethod();  // 子类调用自己的private方法
    }
}

public class Test {
    public static void main(String[] args) {
        Child child = new Child();
        child.callPrivate();      // 输出"Parent的private方法"
        child.callChildPrivate(); // 输出"Child的private方法"
        
        // 以下代码会产生编译错误，因为privateMethod()不可见
        // child.privateMethod();
    }
}
```

### 关键现象
1. **不是真正的重写**：子类中的`privateMethod()`只是恰巧与父类方法同名，两者完全无关
2. **父类调用自己的版本**：通过父类方法调用的private方法仍然是父类的实现
3. **子类调用自己的版本**：子类调用的是自己新定义的方法
4. **编译错误**：直接尝试从外部调用private方法会失败

## 2. 为什么这不是真正的重写？

Java方法重写的必要条件之一是：
- **子类方法必须能够访问父类方法**（即父类方法不能是private）

因为private方法对子类不可见，所以：
- 子类不知道父类有这个private方法
- 子类定义的同名方法是一个全新的方法
- 没有覆盖(Override)关系，只是方法名巧合相同

## 3. @Override注解会报错

如果你尝试用@Override标记这个"重写"：

```java
class Child extends Parent {
    @Override  // 这里会编译错误
    private void privateMethod() {
        System.out.println("Child的private方法");
    }
}
```

编译器会报错：
```
错误: 方法不会覆盖或实现超类型的方法
```

这明确告诉你这不是一个合法的重写。

## 4. 从JVM角度看

在JVM的方法分派机制中：
- private方法是**静态绑定**的（编译时确定）
- 真正的重写方法是**动态绑定**的（运行时确定）
- 子类的"同名"private方法会被视为完全独立的新方法

## 5. 正确理解可见性

Java的访问修饰符决定了方法的可见范围：

| 修饰符 | 类内 | 同包 | 子类 | 其他包 |
|--------|------|------|------|--------|
| private | ✔ | ✖ | ✖ | ✖ |
| (default) | ✔ | ✔ | ✖ | ✖ |
| protected | ✔ | ✔ | ✔ | ✖ |
| public | ✔ | ✔ | ✔ | ✔ |

因为private方法对子类不可见(✖)，所以不存在重写的可能性。

## 6. 设计启示

1. **不要尝试"重写"private方法**：这只会造成混淆，没有实际意义
2. **如果需要子类定制**：将方法改为protected或public
3. **如果不想被重写**：使用final修饰方法
4. **保持清晰**：避免子类中出现与父类private方法同名的方法

## 7. 特殊情况：嵌套类

即使在嵌套类中，private方法的"重写"也有特殊表现：

```java
class Outer {
    private void privateMethod() {
        System.out.println("Outer private");
    }
    
    class Inner extends Outer {
        private void privateMethod() {
            System.out.println("Inner private");
        }
        
        void test() {
            privateMethod();       // 调用Inner的版本
            super.privateMethod(); // 可以调用Outer的private方法！
        }
    }
}
```

这里Inner类可以访问Outer的private方法，因为嵌套类是其外围类的成员。