# Java 方法重写（Override）核心知识点

方法重写是面向对象编程中多态性的重要体现，以下是全面系统的知识点总结：

## 一、基本概念
- **定义**：子类重新定义父类中已有的非私有实例方法
- **核心作用**：实现运行时的多态性（动态绑定）
- **英文术语**：Override（注意与重载Overload区别）

## 二、必要条件（必须全部满足）
1. **方法签名相同**：
   - 方法名完全相同
   - 参数列表完全一致（类型、顺序、数量）
   
2. **访问权限不能更严格**：
   - 可以相同或更宽松（public > protected > 默认 > private）
   - 示例：父类protected → 子类可protected/public

3. **返回类型兼容**：
   - **基本类型：必须完全相同**
   - 引用类型：子类方法返回类型可以是父类方法返回类型的子类（协变返回类型）

4. **异常抛出限制**：
   - 子类方法抛出的异常不能比父类更宽泛
   - 可以不抛出异常或抛出更具体的异常

5. **非静态方法**：
   - **只能重写实例方法**（static方法属于类，不存在重写）

## 三、典型示例
```java
class Animal {
    protected String makeSound() throws IOException {
        return "Animal sound";
    }
}

class Cat extends Animal {
    @Override  // 推荐加上注解
    public String makeSound() throws FileNotFoundException {
        return "Meow";
    }
}
```

## 四、特殊注意事项
1. **private/final/static方法不能被重写**
   - private方法：对子类不可见
   - final方法：禁止修改
   - static方法：隐藏（hide）而非重写

2. **构造方法不能被重写**
   - 构造方法名必须与类名相同

3. **@Override注解**
   - 非必须但强烈推荐
   - 帮助编译器检查是否满足重写条件

4. **super关键字调用父类实现**
   ```java
   @Override
   public void method() {
       super.method(); // 先执行父类逻辑
       // 子类扩展逻辑
   }
   ```

## 五、方法重写 vs 方法重载
| 特性        | 重写(Override)           | 重载(Overload)         |
|------------|-------------------------|-----------------------|
| 方法签名    | 必须相同                | 必须不同（参数列表）   |
| 返回类型    | 必须兼容                | 可以不同              |
| 访问修饰符  | 不能更严格              | 可以不同              |
| 抛出异常    | 不能更宽泛              | 可以不同              |
| 绑定时机    | 运行时动态绑定          | 编译时静态绑定        |
| 所在范围    | 父子类之间              | 同一个类中            |

## 六、常见面试问题
1. 重写和重载的本质区别是什么？
2. 为什么私有方法不能被重写？
3. 协变返回类型是什么？举例说明
4. 静态方法能否被重写？为什么？
5. 如何强制一个方法不能被重写？（final关键字）

## 七、最佳实践
1. 始终使用@Override注解
2. 保持重写方法的行为一致性（里氏替换原则）
3. 谨慎扩展异常类型
4. 对需要禁止重写的方法使用final修饰

理解方法重写机制对于掌握Java多态特性至关重要，也是设计可扩展面向对象系统的基础。