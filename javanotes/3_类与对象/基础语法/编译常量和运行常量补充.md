# 编译时常量和运行时常量的实际案例解析

我来用一个更直观的实际案例帮你彻底理解这两种常量的区别。

## 案例场景：跨类使用的常量

假设我们有两个Java文件：`Constants.java`和`Main.java`

### 文件1：Constants.java
```java
public class Constants {
    // 编译时常量
    public static final int COMPILE_TIME_CONST = 100;
    
    // 运行时常量
    public static final Integer RUNTIME_CONST = 100;
    public static final String RUNTIME_STR = new String("Hello");
}
```

### 文件2：Main.java
```java
public class Main {
    public static void main(String[] args) {
        // 使用编译时常量
        System.out.println("编译时常量: " + Constants.COMPILE_TIME_CONST);
        
        // 使用运行时常量
        System.out.println("运行时常量: " + Constants.RUNTIME_CONST);
        System.out.println("运行时常量字符串: " + Constants.RUNTIME_STR);
    }
}
```

## 关键现象解析

### 1. 编译时常量的行为

当Java编译器处理`Main.java`时：
- 看到`Constants.COMPILE_TIME_CONST`时，会直接把这个引用替换成字面值`100`
- 实际生成的字节码相当于：`System.out.println("编译时常量: " + 100)`

**验证方法**：
1. 编译这两个类：`javac Constants.java Main.java`
2. 修改`Constants.java`中的`COMPILE_TIME_CONST`值为200
3. 只重新编译Constants.java：`javac Constants.java`
4. 运行Main类：`java Main`
5. **你会发现输出仍然是100！** 必须重新编译Main.java才能看到新值

### 2. 运行时常量的行为

对于`RUNTIME_CONST`和`RUNTIME_STR`：
- 编译器会保持对`Constants`类的真实引用
- 每次访问时都会去`Constants`类中获取当前值

**验证方法**：
1. 修改`Constants.java`中的`RUNTIME_CONST`值为200
2. 只重新编译Constants.java
3. 运行Main类
4. **你会立即看到输出变为200**，无需重新编译Main.java

## 更直观的内存模型

```
编译时常量 (COMPILE_TIME_CONST):
Main.class -> 直接包含值100 (编译时替换)

运行时常量 (RUNTIME_CONST):
Main.class -> 指向 -> Constants.class -> 指向 -> 堆内存中的Integer对象
```

## 实际开发中的经典问题

**问题场景**：
- 模块A定义了一个编译时常量`VERSION = 1.0`
- 模块B引用了这个常量
- 你更新了模块A中的`VERSION = 2.0`但忘记重新编译模块B
- 结果模块B仍然使用1.0版本，造成版本不一致

**解决方案**：
1. 要么重新编译所有依赖模块
2. 要么把这个常量改为运行时常量（如通过方法获取）

## 实际应用选择建议

**使用编译时常量**：
- 数学常数（如PI）
- 不会改变的配置（如MAX_RETRY_TIMES=3）
- switch case的case值

**使用运行时常量**：
- 需要从配置文件读取的值
- 可能在不同环境变化的值
- 对象类型的常量（如集合、日期）

## 字节码视角验证

你可以用`javap -c Main.class`查看反编译结果：

对于编译时常量：
```
ldc #2  // 直接加载常量100
```

对于运行时常量：
```
getstatic #3  // 获取Constants.RUNTIME_CONST字段
```

这个底层差异正是两种常量行为不同的根本原因。