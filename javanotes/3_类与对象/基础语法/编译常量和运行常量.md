# 编译时常量与运行时常量

在Java中，常量可以分为编译时常量（Compile-time Constants）和运行时常量（Runtime Constants），它们在行为和使用上有重要区别。

## 编译时常量

### 定义
编译时常量是指在**编译期间**就能确定其值，并且会被编译器直接替换到代码中的常量。

### 特点
1. **编译期确定**：值在编译时就已经确定
2. **直接替换**：编译器会将常量引用替换为实际值
3. **内存分配**：通常存储在方法区的常量池中
4. **优化**：可以被编译器优化

### 如何声明
必须同时满足以下条件：
- 使用`final`修饰
- 使用基本数据类型或String
- **在声明时初始化**
- 初始化表达式是常量表达式（不包含方法调用等运行时操作）

```java
// 编译时常量示例
final int COMPILE_TIME_CONST = 100;          // 基本类型
final String STR_CONST = "Hello";           // String类型
final double PI = 3.1415926;                // 基本类型
final int CALCULATED = 10 * 20 + 30;        // 常量表达式
```

### 使用场景
1. 数组大小声明
2. switch case语句中的case值
3. 注解参数值
4. 需要编译器优化的场合

## 运行时常量

### 定义
运行时常量是指值要到**程序运行时**才能确定的常量。

### 特点
1. **运行时确定**：值在运行时才能计算或获取
2. **内存分配**：存储在堆内存中
3. **灵活性**：可以接受更复杂的初始化方式

### 如何声明
以下情况会产生运行时常量：
- 使用`final`但初始化表达式包含方法调用或非确定性计算
- 使用`final`但初始化延迟到构造方法或静态块中
- 使用包装类（如Integer, Double等）

```java
// 运行时常量示例
final int RUNTIME_CONST = new Random().nextInt(100);  // 运行时计算
final String TIME_NOW = new Date().toString();       // 运行时获取
final List<String> LIST = Arrays.asList("A", "B");   // 集合

// 延迟初始化的final变量
final int delayedInit;
{
    delayedInit = calculateValue();  // 在初始化块中赋值
}

// 包装类
final Integer INTEGER_CONST = 100;   // 自动装箱，运行时对象
```

## 关键区别

| 特性                | 编译时常量                     | 运行时常量                     |
|---------------------|------------------------------|------------------------------|
| 确定时间            | 编译期                       | 运行期                       |
| 存储位置            | 常量池                       | 堆内存                       |
| 初始化方式          | 声明时用常量表达式初始化       | 可以延迟初始化或用非常量表达式 |
| 是否可优化          | 是（内联替换）               | 否                           |
| 跨类引用            | 编译时直接替换值              | 保持引用关系                 |
| 修改触发重新编译    | 是（引用处需要重新编译）      | 否                           |

## 实际影响示例

```java
// 类A
public class A {
    public static final int COMPILE_CONST = 100;  // 编译时常量
    public static final Integer RUNTIME_CONST = 100;  // 运行时常量
}

// 类B
public class B {
    public static void main(String[] args) {
        System.out.println(A.COMPILE_CONST);  // 实际被替换为System.out.println(100)
        System.out.println(A.RUNTIME_CONST);  // 保持引用关系
    }
}
```

如果修改A中的`COMPILE_CONST`为200，必须重新编译B才能看到变化；而修改`RUNTIME_CONST`则不需要重新编译B。

## 最佳实践

1. 优先使用编译时常量，可以获得更好的性能
2. 对于需要复杂初始化或运行时确定的常量，使用运行时常量
3. 注意跨模块使用编译时常量时的重新编译问题
4. 对于配置参数等可能变化的值，即使使用final也应作为运行时常量处理

理解这两种常量的区别对于编写高效、可维护的Java代码非常重要。