在 Java 中，**`protected` 不能用于修饰顶级类（Top-Level Class）**，但可以用于修饰 **内部类（Nested Class）**。以下是详细说明：

---

## **1. 类的访问修饰符规则**
Java 对类的访问控制分为 **顶级类（Top-Level Class）** 和 **内部类（Nested Class）**，规则不同：

| **修饰符**       | **顶级类** | **内部类** | **说明**                     |
|------------------|-----------|-----------|-----------------------------|
| `public`         | ✅ 允许     | ✅ 允许     | 全局可见                     |
| **默认（无）**   | ✅ 允许     | ✅ 允许     | 包级私有（仅当前包可见）      |
| `protected`      | ❌ 不允许   | ✅ 允许     | 仅限内部类使用               |
| `private`        | ❌ 不允许   | ✅ 允许     | 仅限内部类使用               |

---

## **2. 为什么顶级类不能用 `protected`？**
- **语法限制**：Java 语言规范明确规定，顶级类只能是 `public` 或 **默认（包级私有）**。  
- **设计逻辑**：`protected` 的语义是“仅对子类和同包类可见”，但顶级类无法直接通过继承访问（类继承是 `extends`，而非 `protected` 修饰的访问关系）。  
  - 如果允许 `protected class`，它的可见性会和包访问权限混淆，导致设计矛盾。

---

## **3. `protected` 内部类的使用场景**
`protected` 可以修饰 **成员内部类**，表示：  
- **仅允许子类或同包类访问该内部类**。  

### **示例**
```java
public class Outer {
    // protected 内部类
    protected static class Inner {
        void show() {
            System.out.println("Protected Inner Class");
        }
    }
}

// 子类可以访问
class SubOuter extends Outer {
    void test() {
        Inner inner = new Inner(); // 允许访问
        inner.show();
    }
}

// 同包的其他类也可以访问
class SamePackageClass {
    void test() {
        Outer.Inner inner = new Outer.Inner(); // 允许访问
        inner.show();
    }
}

// 不同包的类不能访问
package another;
import Outer.Inner;
class ForeignClass {
    void test() {
        Inner inner = new Inner(); // 编译错误：不可见
    }
}
```

---

## **4. 替代方案：通过继承控制访问**
如果希望某个类的功能 **仅对子类开放**，可以通过以下方式实现类似 `protected` 的效果：  
1. **将类设为默认（包级私有）**，然后在同包中定义一个 `public` 抽象类或接口，子类通过继承/实现间接访问。  
2. **使用工厂模式**，通过受保护的方法返回类的实例。

---

## **5. 总结**
- **❌ 顶级类不能用 `protected`**（语法不允许）。  
- **✅ 内部类可以用 `protected`**，限制仅子类或同包类访问。  
- 如果需要对类实现类似 `protected` 的访问控制，需通过 **包权限+继承** 或 **设计模式** 间接实现。  

这种设计体现了 Java 在 **封装性** 和 **继承体系** 上的严谨性。