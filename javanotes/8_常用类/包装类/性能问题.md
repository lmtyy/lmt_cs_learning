# 包装类性能问题详解（通俗版）

让我用更简单的方式解释第一点关于"对象创建 vs 值复用"的性能问题。

## 1. 基本类型 vs 包装类的本质区别

想象你有一个苹果：
- **基本类型（int）**：就像直接把苹果拿在手里
- **包装类（Integer）**：就像把苹果装进一个盒子里，再拿着盒子

```java
int a = 5;          // 直接拿着苹果
Integer b = 5;       // 把苹果装盒，再拿着盒子
```

## 2. 循环中创建包装类的问题

### 坏例子分析
```java
for (int i = 0; i < 10000; i++) {
    Integer num = new Integer(i); // 每次循环都造一个新盒子
}
```
这相当于：
1. 第一次循环：买苹果→造新盒子→装盒
2. 第二次循环：买苹果→再造新盒子→装盒
3. ...重复1万次
4. 最后你有了1万个盒子（但可能只需要几个）

**问题**：制造1万个盒子很浪费，因为：
- 造盒子要时间（内存分配）
- 处理废弃盒子要时间（垃圾回收）
- 盒子本身也占地方（内存占用）

### 好例子分析
```java
for (int i = 0; i < 10000; i++) {
    Integer num = i; // 使用智能盒子系统
}
```
Java有个"智能盒子系统"（Integer缓存）：
- 对于小数字（-128到127），会**复用同一个盒子**
  - 比如数字5永远用同一个盒子装
- 对于大数字（如1000），虽然会造新盒子，但JVM会优化处理

## 3. 现实世界类比

假设你是快递站工作人员：

**方式一（new Integer）**：
- 每次有快递来，都拿个新箱子打包
- 即使同样的商品也换新箱子
- 结果：仓库堆满空箱子，清理很费劲

**方式二（Integer.valueOf/自动装箱）**：
- 小件商品用标准固定尺寸的箱子（缓存）
- 大件商品才用新箱子
- 能复用的箱子尽量复用

## 4. 为什么这会影响性能？

看这个具体例子：
```java
// 方式一：每次new创建
long start = System.currentTimeMillis();
for (int i = 0; i < 1000000; i++) {
    Integer num = new Integer(i); // 每次新建对象
}
System.out.println("耗时：" + (System.currentTimeMillis()-start) + "ms");

// 方式二：使用自动装箱
start = System.currentTimeMillis();
for (int i = 0; i < 1000000; i++) {
    Integer num = i; // 自动装箱，可能使用缓存
}
System.out.println("耗时：" + (System.currentTimeMillis()-start) + "ms");
```

典型结果：
```
new Integer方式耗时：25ms
自动装箱方式耗时：12ms
```

## 5. 什么时候该担心这个问题？

以下情况需要特别注意：
1. **超大规模循环**（循环数百万次）
2. **高性能计算场景**
3. **Android等内存受限环境**
4. **实时交易系统**

普通业务代码中偶尔使用包装类不会有明显影响。

## 6. 简单记忆法则

✅ **好的做法**：
```java
// 在循环内使用基本类型
for (int i = 0; i < 10000; i++) { ... }

// 需要包装类时用自动装箱
List<Integer> list = Arrays.asList(1, 2, 3); 
```

❌ **不好的做法**：
```java
// 在循环内频繁新建包装对象
for (Integer i = 0; i < 10000; i++) { ... }

// 显式调用构造方法（Java9+）
Integer num = new Integer(10); 
```

记住：包装类就像"盒子"，基本类型就像"裸装物品"。在不需要盒子的场合，直接使用物品更高效！