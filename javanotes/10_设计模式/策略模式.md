# Java 策略模式详解

策略模式(Strategy Pattern)是一种行为型设计模式，它定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户端。

## 为什么需要策略模式？

1. **避免多重条件语句**：替换大量的if-else或switch-case语句
2. **算法自由切换**：运行时动态选择算法
3. **扩展性好**：新增策略不影响现有代码
4. **隔离变化**：将算法与使用算法的代码分离
5. **复用算法**：不同环境可以复用相同的策略

## 策略模式的核心组成

1. **策略接口(Strategy Interface)**：定义所有支持的算法的公共接口
2. **具体策略类(Concrete Strategies)**：实现策略接口的具体算法
3. **上下文类(Context)**：持有一个策略对象的引用，用策略对象来配置其行为

## 策略模式实现示例

### 1. 定义策略接口
```java
public interface PaymentStrategy {
    void pay(int amount);
}
```

### 2. 实现具体策略类
```java
// 信用卡支付策略
public class CreditCardStrategy implements PaymentStrategy {
    private String name;
    private String cardNumber;
    private String cvv;
    private String dateOfExpiry;
    
    public CreditCardStrategy(String name, String cardNumber, String cvv, String dateOfExpiry) {
        this.name = name;
        this.cardNumber = cardNumber;
        this.cvv = cvv;
        this.dateOfExpiry = dateOfExpiry;
    }
    
    @Override
    public void pay(int amount) {
        System.out.println(amount + " paid with credit/debit card");
    }
}

// 支付宝支付策略
public class AlipayStrategy implements PaymentStrategy {
    private String emailId;
    private String password;
    
    public AlipayStrategy(String emailId, String password) {
        this.emailId = emailId;
        this.password = password;
    }
    
    @Override
    public void pay(int amount) {
        System.out.println(amount + " paid using Alipay");
    }
}

// 微信支付策略
public class WechatPayStrategy implements PaymentStrategy {
    private String appId;
    private String password;
    
    public WechatPayStrategy(String appId, String password) {
        this.appId = appId;
        this.password = password;
    }
    
    @Override
    public void pay(int amount) {
        System.out.println(amount + " paid using WeChat Pay");
    }
}
```

### 3. 创建上下文类
```java
public class PaymentContext {
    private PaymentStrategy strategy;
    
    public PaymentContext(PaymentStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void executePayment(int amount) {
        strategy.pay(amount);
    }
    
    // 动态改变策略
    public void setStrategy(PaymentStrategy strategy) {
        this.strategy = strategy;
    }
}
```

### 4. 客户端使用
```java
public class StrategyPatternDemo {
    public static void main(String[] args) {
        // 创建不同的支付策略
        PaymentStrategy creditCard = new CreditCardStrategy("John Doe", "123456789", "123", "12/25");
        PaymentStrategy alipay = new AlipayStrategy("john@example.com", "mypwd");
        PaymentStrategy wechatPay = new WechatPayStrategy("wx123456", "mypwd");
        
        // 创建支付上下文并使用信用卡支付
        PaymentContext context = new PaymentContext(creditCard);
        context.executePayment(100);
        
        // 切换为支付宝支付
        context.setStrategy(alipay);
        context.executePayment(200);
        
        // 切换为微信支付
        context.setStrategy(wechatPay);
        context.executePayment(300);
    }
}
```

## 策略模式的优点

1. **开闭原则**：无需修改上下文即可引入新策略
2. **消除条件语句**：避免使用多重条件转移语句
3. **算法复用**：相同策略可被不同上下文使用
4. **灵活性**：运行时切换算法
5. **单一职责**：每个策略类负责一个具体算法

## 策略模式的缺点

1. **客户端必须了解所有策略**：客户端需要知道不同策略的区别以选择合适策略
2. **策略类增多**：如果算法很少变化，可能会增加类的数量
3. **通信开销**：策略与上下文之间可能需要交换数据，增加通信成本

## 实际应用场景

1. **支付系统**：如上面示例，支持多种支付方式
2. **排序算法**：根据数据量选择快速排序、归并排序等
3. **压缩算法**：选择ZIP、RAR等不同压缩策略
4. **导航系统**：根据需求选择最短路径、最快路径等策略
5. **游戏AI**：不同的敌人行为策略
6. **折扣系统**：会员折扣、节日折扣等不同计算策略

## 策略模式与状态模式的区别

虽然结构相似，但两者意图不同：
- **策略模式**：客户端主动选择算法，策略之间通常互不了解
- **状态模式**：状态转换由内部条件触发，状态之间通常相互了解

## 高级应用：结合工厂模式

```java
public class StrategyFactory {
    public static PaymentStrategy getStrategy(String type) {
        switch(type) {
            case "CreditCard":
                return new CreditCardStrategy("default", "000000000", "000", "00/00");
            case "Alipay":
                return new AlipayStrategy("default@example.com", "default");
            case "WechatPay":
                return new WechatPayStrategy("wx000000", "default");
            default:
                throw new IllegalArgumentException("Unknown payment type");
        }
    }
}

// 使用方式
PaymentStrategy strategy = StrategyFactory.getStrategy("Alipay");
PaymentContext context = new PaymentContext(strategy);
context.executePayment(500);
```

策略模式是Java集合框架中常用的模式之一，例如`Comparator`接口就是策略模式的典型应用，允许在运行时指定不同的排序策略。