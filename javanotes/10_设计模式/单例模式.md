# Java 单例模式详解

单例模式(Singleton Pattern)是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点。

## 为什么需要单例模式？

1. **控制资源访问**：如数据库连接池、线程池
2. **共享配置信息**：全局配置对象
3. **减少系统开销**：避免频繁创建销毁对象
4. **保持一致性**：确保所有使用该对象的地方都使用同一个实例

## 单例模式的实现方式

### 1. 懒汉式（线程不安全）
```java
public class Singleton {
    private static Singleton instance;
    
    private Singleton() {}  // 私有构造函数
    
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```
**缺点**：多线程环境下可能创建多个实例

### 2. 懒汉式（线程安全，同步方法）
```java
public class Singleton {
    private static Singleton instance;
    
    private Singleton() {}
    
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```
**缺点**：每次获取实例都要同步，性能较差

### 3. 双重检查锁（DCL）
```java
public class Singleton {
    private volatile static Singleton instance;
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
**特点**：
- 使用`volatile`防止指令重排序
- 第一次检查避免不必要的同步
- 第二次检查确保单例
- 性能较好，推荐使用

### 4. 饿汉式
```java
public class Singleton {
    private static final Singleton instance = new Singleton();
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        return instance;
    }
}
```
**特点**：
- 类加载时就初始化，浪费内存
- 线程安全，实现简单
- 没有延迟加载的优势

### 5. 静态内部类实现
```java
public class Singleton {
    private Singleton() {}
    
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```
**特点**：
- 线程安全
- 延迟加载（只有调用getInstance()时才加载SingletonHolder类）
- 实现简单，推荐使用

### 6. 枚举实现（Effective Java推荐）
```java
public enum Singleton {
    INSTANCE;
    
    public void doSomething() {
        // 实例方法
    }
}
```
**特点**：
- 线程安全
- 防止反序列化重新创建对象
- 实现简单
- 枚举方式是最佳的单例实现方式

## 单例模式注意事项

1. **反射攻击**：可以通过反射调用私有构造函数创建新实例
   - 解决方法：在构造函数中添加检查，如果实例已存在则抛出异常

2. **序列化/反序列化**：反序列化时会创建新实例
   - 解决方法：实现`readResolve()`方法返回单例实例

3. **多类加载器环境**：不同类加载器加载同一个类会创建多个实例
   - 解决方法：指定类加载器或使用枚举方式

## 实际应用场景

1. 数据库连接池
2. 系统配置管理
3. 日志记录器
4. 应用程序的对话框
5. 缓存系统
6. 线程池

## 代码示例（完整线程安全实现）

```java
import java.io.Serializable;

public class Singleton implements Serializable {
    private static volatile Singleton instance;
    
    private Singleton() {
        // 防止反射攻击
        if (instance != null) {
            throw new IllegalStateException("Already initialized");
        }
    }
    
    public static Singleton getInstance() {
        Singleton result = instance;
        if (result == null) {
            synchronized (Singleton.class) {
                result = instance;
                if (result == null) {
                    instance = result = new Singleton();
                }
            }
        }
        return result;
    }
    
    // 防止反序列化创建新实例
    protected Object readResolve() {
        return getInstance();
    }
}
```

单例模式虽然简单，但要实现一个完全线程安全、防止反射和序列化攻击的单例需要考虑很多细节。在大多数情况下，枚举实现是最简单安全的选择。