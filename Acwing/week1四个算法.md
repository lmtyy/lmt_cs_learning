# 快速排序

思想：分而治之

步骤：
1.选取一个参数；
2.将数组分为两边进行排序；
3.递归

```c++
#include <iostream>
#include <string>

using namespace std;

int n;
const int N = 1e6 + 10;
int q[N];

void quick_sort(int q[], int l, int r) {
    if (l>=r) return;
    int x = q[(l+r) >> 1], i = l - 1, j = r + 1;
    while (i < j) {
        do i++; while (q[i] < x);
        do j--; while (q[j] > x);
        if(i<j) swap(q[i] , q[j]);
    }
    quick_sort(q, l, j);
    quick_sort(q, j+1, r);
}

int main() {
    scanf("%d",&n);
    for (int i = 0; i < n; i++) scanf("%d", &q[i]);
    
    quick_sort(q, 0, n-1);
    for (int i = 0; i < n; i++) printf("%d ", q[i]);
}

```



快速排序时间复杂度：

### 核心结论

*   **平均情况时间复杂度：O(n log n)**
*   **最佳情况时间复杂度：O(n log n)**
*   **最差情况时间复杂度：O(n²)**
*   **空间复杂度：平均 O(log n)，最差 O(n)**

---

### 详细分解

和归并排序一样，快速排序也采用“**分治法**”（Divide and Conquer）策略，但其核心是“**分区**”（Partition）操作：
1.  **挑基准**：从数组中选一个元素作为“基准”（pivot）。
2.  **分区**：重新排列数组，所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准后面（相等的数可以到任一边）。在这个分区退出之后，该基准就处于数组的中间位置。这个称为分区操作。
3.  **递归**：递归地将小于基准值的子数组和大于基准值的子数组排序。

时间复杂度主要取决于**分区操作产生的两个子数组是否平衡**。

#### 1. 最佳情况 (Best Case) - O(n log n)

**场景**：每次选择的基准都能将当前数组**几乎完美地对半分割**。

*   **递归深度**：每次都对半分割，递归树的深度为 **log n**。
*   **每层工作量**：每一层都需要对所有的元素进行一次遍历（分区操作），总计工作量是 **O(n)**。
*   **总工作量**：O(每层工作量 × 深度) = O(n) × O(log n) = **O(n log n)**。



#### 2. 平均情况 (Average Case) - O(n log n)

**场景**：基准的选择是**随机的**，有时分割得均衡，有时不均衡。但平均下来，分割是相对均衡的。

*   数学证明（如主定理）和大量实验表明，即使分区不完全平衡，只要不是极端不平衡，快速排序的平均时间复杂度仍然是 **O(n log n)**。这也是快速排序成为实际应用中最快排序算法之一的原因。

#### 3. 最差情况 (Worst Case) - O(n²)

**场景**：每次选择的基准都是**当前数组中的最大或最小元素**。这会导致极度不平衡的分区。

*   例如，一个已经有序的数组（正序或逆序），如果总是选择第一个或最后一个元素作为基准，就会发生这种情况。
*   **递归深度**：每次分区后，一个子数组包含 `n-1` 个元素，另一个子数组为空。递归树退化成一个深度为 **n** 的链。
*   **每层工作量**：第 `i` 层需要的工作量是 `O(n-i)`。
*   **总工作量**：这是一个等差数列求和：`n + (n-1) + (n-2) + ... + 1 = n(n+1)/2`，即 **O(n²)**。



---

### 如何避免最差情况？

最差情况 O(n²) 是快速排序的主要缺点，但可以通过以下策略有效避免：

1.  **随机化基准选择 (Randomized Pivot)**：不总是选择第一个元素，而是从当前子数组中**随机选择一个元素**作为基准。这将最坏情况的出现概率降到了最低，在实际应用中非常有效。
2.  **三数取中法 (Median-of-Three)**：取当前数组的**头、中、尾**三个元素，选择这三个数的中位数作为基准。这种方法能很好地避免在已部分排序的数组上出现最坏性能。

使用这些优化后，快速排序在实际应用中几乎总能达到 **O(n log n)** 的效率。

### 空间复杂度

快速排序是**原地排序**（in-place），但递归调用需要使用栈空间。
*   **最佳/平均情况**：递归深度为 O(log n)，所以空间复杂度是 **O(log n)**。
*   **最差情况**：递归深度为 O(n)，所以空间复杂度是 **O(n)**。

### 与归并排序的对比

| 特性               | 快速排序                     | 归并排序                      |
| :----------------- | :--------------------------- | :---------------------------- |
| **平均时间复杂度** | **O(n log n)**               | **O(n log n)**                |
| **最差时间复杂度** | **O(n²)**                    | **O(n log n)**                |
| **最佳时间复杂度** | **O(n log n)**               | **O(n log n)**                |
| **空间复杂度**     | **平均 O(log n)，最差 O(n)** | **O(n)**                      |
| **稳定性**         | **通常不稳定**               | **稳定**                      |
| **排序方式**       | **原地排序 (In-place)**      | **非原地排序 (Not in-place)** |
| **效率来源**       | **引用局部性，缓存友好**     | **稳定的 O(n log n)**         |

**为什么快速排序通常更快？**
虽然都是 O(n log n)，但快速排序的**常数因子通常更小**。它的内循环中的操作（比较和交换）非常高效，并且对计算机的**缓存机制更友好**（它主要顺序访问数据）。

### 总结

快速排序是一种高效但不稳定的排序算法。
*   其**平均性能非常好**，是实际应用中最常用的排序算法之一（如编程语言标准库中的排序函数 often 使用快速排序的变体，如 `introsort`）。
*   其**最差性能 O(n²)** 可以通过**随机化选择基准**来有效避免。
*   它以**较小的空间开销（递归栈）** 实现了高效的排序。

# 归并排序

思想：分而治之

步骤：
1.确定一个分界点
2.递归排序左和右
3.归并-合二为一

```c++
#include <iostream>

using namespace std;

const int N = 1e6 + 10;
int n;
int q[N], tep[N];

void merge_sort(int q[], int l, int r){
  if(l >= r) return;
  int mid = (l + r) >> 1;
  merge_sort(q, l, mid), merge_sort(q, mid + 1, r);
  int k = 0, i = l, j = mid + 1;
  while (i <= mid && j <= r)
      if (q[i] <= q[j]) tep[k++] = q[i++];
      else tep[k++] = q[j++];
  while (i <= mid) tep[k++] = q[i++];
  while (j <= r) tep[k++] = q[j++];
  for (i = l, j=0; i <= r; i++, j++) q[i] = tep[j];
}

int main(){
  scanf("%d", &n);
  for (int i = 0; i < n; i++) scanf("%d", &q[i]);
  
  merge_sort(q, 0, n-1);
  for (int i = 0; i < n; i++) printf("%d ", q[i]);
}
```





归并排序（Merge Sort）的时间复杂度。

### 核心结论

*   **最佳情况、最差情况、平均情况的时间复杂度均为 O(n log n)**。
*   **空间复杂度为 O(n)**。

归并排序是效率非常稳定的排序算法，其性能几乎不受输入数据顺序的影响。

---

### 详细分解

归并排序采用“**分治法**”（Divide and Conquer）策略，其过程主要分为两个步骤：
1.  **分**：递归地将当前数组平均分割成两个子数组，直到每个子数组只包含一个元素（一个元素的数组自然是有序的）。
2.  **治**：递归地将两个已排序的子数组合并成一个大的有序数组，直到最终合并成一个完整的排序数组。

时间复杂度就来自于这两个步骤的操作成本。

#### 1. “分”的过程 - 递归的深度

想象一下，你有一张很大的纸，你每次都把它对半撕开，要撕多少次才能把它撕成一张张只有一个小字的碎片？

对于一个包含 `n` 个元素的数组，每次都是对半分割。设递归深度为 `k`，那么：
`n / 2^k = 1` -> `2^k = n` -> `k = log₂n`

所以，递归树的深度是 **log₂n**（通常简写为 **log n**，在算法分析中，对数函数的底数2通常被省略，因为不同底数之间只差一个常数倍，而大O表示法会忽略常数）。



#### 2. “治”的过程 - 每层的操作量

在每一层递归中，无论哪一层，我们都需要进行“合并”操作。

*   第一层（最顶层）：将2个长度为 `n/2` 的数组合并成一个长度为 `n` 的数组。合并操作需要比较和移动元素，最多需要 `n` 次操作。
*   第二层：有2个子问题，每个问题需要合并2个长度为 `n/4` 的数组成一个 `n/2` 的数组。每个合并操作需要 `n/2` 次操作。2 * `n/2` = `n` 次操作。
*   第三层：有4个子问题，每个问题需要合并2个长度为 `n/8` 的数组成一个 `n/4` 的数组。4 * `n/4` = `n` 次操作。
*   ...
*   最后一层：有 `n` 个子问题（每个元素为一个数组），合并它们需要 `n` 次操作？（实际上最后一层是单个元素，合并操作非常简单）。更准确地说，每一层的合并操作总数都是 **O(n)**。

#### 3. 总的时间复杂度

现在我们有了两个部分：
*   总共有 **O(log n)** 层。
*   每一层都需要 **O(n)** 次操作。

因此，总的时间复杂度就是：
**O(每层操作数 × 层数) = O(n) × O(log n) = O(n log n)**

---

### 为什么总是 O(n log n)？

*   **最佳情况**：即使输入数组已经是有序的，归并排序仍然要不折不扣地执行“分”和“治”的所有步骤。它无法提前知道数组是否有序，所以它的最佳、平均、最差情况时间复杂度都是 **O(n log n)**。
*   **最差情况**：最差情况发生在合并时，需要比较的次数最多，但即使是最多，每次合并的操作次数仍然是线性的（O(n)），所以总时间仍然是 **O(n log n)**。

### 与其他排序算法的对比

| 排序算法     | 平均情况       | 最佳情况       | 最差情况       | 空间复杂度 | 稳定性   |
| :----------- | :------------- | :------------- | :------------- | :--------- | :------- |
| **归并排序** | **O(n log n)** | **O(n log n)** | **O(n log n)** | **O(n)**   | **稳定** |
| 快速排序     | O(n log n)     | O(n log n)     | O(n²)          | O(log n)   | 不稳定   |
| 堆排序       | O(n log n)     | O(n log n)     | O(n log n)     | O(1)       | 不稳定   |
| 冒泡排序     | O(n²)          | O(n)           | O(n²)          | O(1)       | 稳定     |
| 插入排序     | O(n²)          | O(n)           | O(n²)          | O(1)       | 稳定     |

**稳定性**：归并排序是稳定的，因为在合并两个子数组时，如果遇到相等的元素，我们可以优先选择前一个子数组的元素，从而保证相等元素的原始相对顺序不变。

# 整数二分

```c++
#include <iostream>

using namespace std;

const int N = 100010;
int q[N];
int n, m;

int main(){
    scanf("%d%d", &n, &m);
    for(int i = 0; i < n; i++) scanf("%d", &q[i]);
    
    while(m--){
        int x;
        scanf("%d", &x);
        int l = 0, r = n - 1;
        while(l < r){
            int mid = (l + r) / 2;
            if(q[mid] >= x) r = mid;
            else l = mid + 1;
        }
        if (q[l] != x) cout << "-1 -1" << endl;
        else {
            cout << l << " ";
            int l = 0, r = n - 1;
            while(l < r){
                int mid = (r + l + 1) / 2;
                if(q[mid] <= x) l = mid;
                else r = mid - 1; 
            }
            cout << l <<endl;
        }
    }
    return 0;
}
```



# 浮点数二分

```c++
#include <isstream>

using namespace std;

int main(){
  double x;
  cin << x;
  double l = 0, r = x;
  while (l - r > 1e-8){
    double mid = (l + r) / 2;
    if (mid * mid > x) r = mid;
    else l = mid;
  }
  print("%1f", l);
  return 0;
}
```

