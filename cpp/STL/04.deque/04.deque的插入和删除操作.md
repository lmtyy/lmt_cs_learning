好的，我们来详细讲解一下 C++ STL 中 `deque`（双端队列）的插入和删除操作。

`deque` 最大的特点就是它支持在头尾两端进行高效地插入和删除，其名称“双端队列”也正源于此。

---

### 1. `deque` 的插入操作

`deque` 提供了多种插入方法，最常用的是在两端插入，也支持在任意位置插入。

#### a. 在尾部插入

1.  **`push_back(const T& value)`** 或 **`push_back(T&& value)`** (C++11 移动语义)
    *   **功能**：在 `deque` 的末尾添加一个元素。
    *   **时间复杂度**：**平摊常数 O(1)**。这是 `deque` 的核心优势之一。
    *   **示例**：
    ```cpp
    #include <iostream>
    #include <deque>
    using namespace std;
    
    int main() {
        deque<int> dq = {1, 2, 3};
    
        dq.push_back(4); // 在尾部插入 4
        // dq 现在为: {1, 2, 3, 4}
    
        for (auto num : dq) {
            cout << num << " "; // 输出: 1 2 3 4
        }
        return 0;
    }
    ```

#### b. 在头部插入

1.  **`push_front(const T& value)`** 或 **`push_front(T&& value)`**
    *   **功能**：在 `deque` 的开头添加一个元素。
    *   **时间复杂度**：**平摊常数 O(1)**。这是 `deque` 相对于 `vector` 的另一个核心优势（`vector` 的 `push_front` 是 O(n) 的）。
    *   **示例**：
    ```cpp
    deque<int> dq = {2, 3, 4};
    
    dq.push_front(1); // 在头部插入 1
    // dq 现在为: {1, 2, 3, 4}
    ```

#### c. 在任意位置插入

1.  **`insert()`**
    *   这是一个功能更强大但也更复杂的成员函数，有多个重载版本。
    *   **时间复杂度**：**线性 O(n)**。因为插入点之后的所有元素都需要移动。插入位置越靠近中间，需要移动的元素越多，性能开销越大。

    **常用版本：**

    *   **`iterator insert(const_iterator pos, const T& value)`**
        *   在迭代器 `pos` 指向的位置**之前**插入一个元素 `value`。
        *   返回指向**新插入元素**的迭代器。
        ```cpp
        deque<int> dq = {1, 3, 4};
        auto it = dq.begin() + 1; // it 指向 3
        
        it = dq.insert(it, 2); // 在 3 之前插入 2
        // dq 现在为: {1, 2, 3, 4}
        // it 现在指向新插入的 2
        ```

    *   **`iterator insert(const_iterator pos, size_type count, const T& value)`**
        *   在 `pos` 位置之前插入 `count` 个 `value`。
        ```cpp
        deque<int> dq = {1, 5};
        dq.insert(dq.begin() + 1, 3, 9); // 在 5 之前插入 3 个 9
        // dq 现在为: {1, 9, 9, 9, 5}
        ```

    *   **`iterator insert(const_iterator pos, InputIt first, InputIt last)`**
        *   在 `pos` 位置之前插入来自范围 `[first, last)` 的其他元素（例如，来自另一个数组或容器）。
        ```cpp
        vector<int> vec = {7, 8};
        deque<int> dq = {1, 4};
        dq.insert(dq.begin() + 1, vec.begin(), vec.end()); // 插入整个 vector
        // dq 现在为: {1, 7, 8, 4}
        ```

    *   **`iterator insert(const_iterator pos, initializer_list<T> ilist)`** (C++11)
        *   在 `pos` 位置之前插入一个初始化列表。
        ```cpp
        deque<int> dq = {1, 5};
        dq.insert(dq.begin() + 1, {2, 3, 4}); // 插入初始化列表
        // dq 现在为: {1, 2, 3, 4, 5}
        ```

---

### 2. `deque` 的删除操作

与插入类似，删除也支持从两端或任意位置进行。

#### a. 从尾部删除

1.  **`pop_back()`**
    *   **功能**：移除 `deque` 的最后一个元素。
    *   **注意**：此函数**不返回**被删除的元素。在调用之前，应确保 `deque` 非空，否则行为未定义（UB）。
    *   **时间复杂度**：**常数 O(1)**。
    *   **示例**：
    ```cpp
    deque<int> dq = {1, 2, 3, 4};
    
    dq.pop_back(); // 删除末尾的 4
    // dq 现在为: {1, 2, 3}
    ```

#### b. 从头部删除

1.  **`pop_front()`**
    *   **功能**：移除 `deque` 的第一个元素。
    *   **注意**：同样**不返回**被删除的元素。调用前需确保 `deque` 非空。
    *   **时间复杂度**：**常数 O(1)**。
    *   **示例**：
    ```cpp
    deque<int> dq = {1, 2, 3};
    
    dq.pop_front(); // 删除头部的 1
    // dq 现在为: {2, 3}
    ```

#### c. 从任意位置删除

1.  **`erase()`**
    *   用于删除一个或一段元素。
    *   **时间复杂度**：**线性 O(n)**。因为删除点之后的所有元素都需要移动。

    **常用版本：**

    *   **`iterator erase(const_iterator pos)`**
        *   删除迭代器 `pos` 指向位置的元素。
        *   返回指向被删除元素之后那个元素的迭代器。如果删除的是最后一个元素，则返回 `end()`。
        ```cpp
        deque<int> dq = {1, 2, 3, 4, 5};
        auto it = dq.begin() + 2; // it 指向 3
        
        it = dq.erase(it); // 删除 3
        // dq 现在为: {1, 2, 4, 5}
        // it 现在指向 4
        ```

    *   **`iterator erase(const_iterator first, const_iterator last)`**
        *   删除范围 `[first, last)` 内的所有元素。
        ```cpp
        deque<int> dq = {1, 2, 3, 4, 5, 6};
        auto it = dq.erase(dq.begin() + 1, dq.begin() + 4); // 删除 [2, 3, 4)
        // dq 现在为: {1, 5, 6}
        // it 现在指向 5
        ```

2.  **`clear()`**
    *   **功能**：清空 `deque`，移除所有元素，使其大小变为 0。
    *   **时间复杂度**：**线性 O(n)**，n 为元素个数。

---

### 总结与对比 `vector`

| 操作         | `deque`                   | `vector`                      | 说明                   |
| :----------- | :------------------------ | :---------------------------- | :--------------------- |
| **尾部插入** | `push_back()` - **O(1)**  | `push_back()` - **平摊 O(1)** | 两者效率相当           |
| **头部插入** | `push_front()` - **O(1)** | `push_front()` - **O(n)**     | **`deque` 的巨大优势** |
| **中间插入** | `insert()` - **O(n)**     | `insert()` - **O(n)**         | 效率相当，都较慢       |
| **尾部删除** | `pop_back()` - **O(1)**   | `pop_back()` - **O(1)**       | 两者效率相当           |
| **头部删除** | `pop_front()` - **O(1)**  | `pop_front()` - **O(n)**      | **`deque` 的巨大优势** |
| **中间删除** | `erase()` - **O(n)**      | `erase()` - **O(n)**          | 效率相当，都较慢       |
| **随机访问** | `operator[]` - **O(1)**   | `operator[]` - **O(1)**       | 两者效率相当           |

### 核心要点

1.  **首选两端操作**：当你需要频繁在序列的**头尾两端**进行插入或删除时，`deque` 是比 `vector` 更合适的选择（例如实现一个队列）。
2.  **慎用中间操作**：尽管 `deque` 提供了 `insert` 和 `erase`，但它们的性能开销很大（O(n)）。如果需要在中间频繁操作，`list` 或 `forward_list` 可能更合适。
3.  **迭代器失效**：在 `deque` 中间进行插入或删除操作会使所有迭代器和引用失效。而在头尾操作时，通常只有部分迭代器会失效，规则比 `vector` 复杂，但最安全的做法是：**在修改 `deque` 后，假定所有之前的迭代器都失效**。