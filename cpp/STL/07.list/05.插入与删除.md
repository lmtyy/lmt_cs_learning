我来详细讲解C++中list容器的插入和删除操作。

## list容器简介

`list`是C++标准模板库(STL)中的双向链表容器，支持高效的插入和删除操作。

```cpp
#include <iostream>
#include <list>
using namespace std;
```

## 插入操作

### 1. push_back() - 在末尾插入元素
```cpp
void demoPushBack() {
    list<int> myList;
    
    myList.push_back(10);
    myList.push_back(20);
    myList.push_back(30);
    
    cout << "push_back后的list: ";
    for(int num : myList) {
        cout << num << " ";
    }
    cout << endl;
    // 输出: 10 20 30
}
```

### 2. push_front() - 在开头插入元素
```cpp
void demoPushFront() {
    list<int> myList = {20, 30};
    
    myList.push_front(10);
    myList.push_front(5);
    
    cout << "push_front后的list: ";
    for(int num : myList) {
        cout << num << " ";
    }
    cout << endl;
    // 输出: 5 10 20 30
}
```

### 3. insert() - 在指定位置插入元素
```cpp
void demoInsert() {
    list<int> myList = {10, 30, 40};
    
    // 在第二个位置插入20
    auto it = myList.begin();
    advance(it, 1); // 移动到第二个位置
    myList.insert(it, 20);
    
    cout << "insert后的list: ";
    for(int num : myList) {
        cout << num << " ";
    }
    cout << endl;
    // 输出: 10 20 30 40
    
    // 插入多个相同元素
    it = myList.begin();
    myList.insert(it, 3, 5); // 在开头插入3个5
    
    cout << "插入多个元素后的list: ";
    for(int num : myList) {
        cout << num << " ";
    }
    cout << endl;
    // 输出: 5 5 5 10 20 30 40
}
```

### 4. emplace()系列 - 原地构造元素
```cpp
void demoEmplace() {
    list<pair<int, string>> myList;
    
    // emplace_back - 在末尾原地构造
    myList.emplace_back(1, "Alice");
    myList.emplace_back(2, "Bob");
    
    // emplace_front - 在开头原地构造
    myList.emplace_front(0, "First");
    
    // emplace - 在指定位置原地构造
    auto it = myList.begin();
    advance(it, 2);
    myList.emplace(it, 1, "Middle");
    
    cout << "emplace后的list: ";
    for(auto& p : myList) {
        cout << "(" << p.first << "," << p.second << ") ";
    }
    cout << endl;
}
```

## 删除操作

### 1. pop_back() - 删除末尾元素
```cpp
void demoPopBack() {
    list<int> myList = {10, 20, 30, 40};
    
    myList.pop_back();
    
    cout << "pop_back后的list: ";
    for(int num : myList) {
        cout << num << " ";
    }
    cout << endl;
    // 输出: 10 20 30
}
```

### 2. pop_front() - 删除开头元素
```cpp
void demoPopFront() {
    list<int> myList = {10, 20, 30, 40};
    
    myList.pop_front();
    
    cout << "pop_front后的list: ";
    for(int num : myList) {
        cout << num << " ";
    }
    cout << endl;
    // 输出: 20 30 40
}
```

### 3. erase() - 删除指定位置元素
```cpp
void demoErase() {
    list<int> myList = {10, 20, 30, 40, 50};
    
    // 删除单个元素
    auto it = myList.begin();
    advance(it, 2); // 指向第三个元素(30)
    it = myList.erase(it); // 返回被删除元素的下一个位置
    
    cout << "删除单个元素后的list: ";
    for(int num : myList) {
        cout << num << " ";
    }
    cout << endl;
    // 输出: 10 20 40 50
    
    // 删除范围元素
    auto first = myList.begin();
    auto last = myList.begin();
    advance(first, 1);
    advance(last, 3);
    myList.erase(first, last); // 删除[first, last)范围的元素
    
    cout << "删除范围元素后的list: ";
    for(int num : myList) {
        cout << num << " ";
    }
    cout << endl;
    // 输出: 10 50
}
```

### 4. remove() - 删除所有指定值的元素
```cpp
void demoRemove() {
    list<int> myList = {10, 20, 10, 30, 10, 40};
    
    myList.remove(10); // 删除所有值为10的元素
    
    cout << "remove后的list: ";
    for(int num : myList) {
        cout << num << " ";
    }
    cout << endl;
    // 输出: 20 30 40
}
```

### 5. remove_if() - 条件删除
```cpp
void demoRemoveIf() {
    list<int> myList = {5, 12, 8, 15, 3, 20};
    
    // 删除所有大于10的元素
    myList.remove_if([](int x) { return x > 10; });
    
    cout << "remove_if后的list: ";
    for(int num : myList) {
        cout << num << " ";
    }
    cout << endl;
    // 输出: 5 8 3
}
```

### 6. clear() - 清空所有元素
```cpp
void demoClear() {
    list<int> myList = {10, 20, 30, 40};
    
    cout << "清空前size: " << myList.size() << endl;
    
    myList.clear();
    
    cout << "清空后size: " << myList.size() << endl;
    cout << "清空后是否为空: " << (myList.empty() ? "是" : "否") << endl;
}
```

### 7. unique() - 删除连续重复元素
```cpp
void demoUnique() {
    list<int> myList = {1, 2, 2, 3, 3, 3, 4, 2, 5};
    
    myList.unique(); // 只删除连续的重复元素
    
    cout << "unique后的list: ";
    for(int num : myList) {
        cout << num << " ";
    }
    cout << endl;
    // 输出: 1 2 3 4 2 5
}
```

## 综合示例

```cpp
void comprehensiveDemo() {
    list<int> myList;
    
    // 插入操作
    cout << "=== 插入操作演示 ===" << endl;
    myList.push_back(100);
    myList.push_front(50);
    myList.insert(++myList.begin(), 75);
    myList.push_back(100);
    myList.push_back(150);
    
    cout << "初始list: ";
    for(int num : myList) {
        cout << num << " ";
    }
    cout << endl;
    
    // 删除操作
    cout << "\n=== 删除操作演示 ===" << endl;
    myList.pop_front();
    myList.remove(100); // 删除所有100
    
    cout << "删除后的list: ";
    for(int num : myList) {
        cout << num << " ";
    }
    cout << endl;
    
    // 条件删除
    myList.remove_if([](int x) { return x < 100; });
    
    cout << "条件删除后的list: ";
    for(int num : myList) {
        cout << num << " ";
    }
    cout << endl;
}
```

## 主函数测试

```cpp
int main() {
    cout << "list插入和删除操作演示" << endl;
    cout << "=====================" << endl;
    
    demoPushBack();
    demoPushFront();
    demoInsert();
    demoEmplace();
    demoPopBack();
    demoPopFront();
    demoErase();
    demoRemove();
    demoRemoveIf();
    demoClear();
    demoUnique();
    comprehensiveDemo();
    
    return 0;
}
```

## 重要注意事项

1. **迭代器失效**：只有指向被删除元素的迭代器会失效，其他迭代器仍然有效
2. **性能**：list的插入和删除操作都是O(1)时间复杂度
3. **emplace vs insert**：emplace系列函数可以避免不必要的拷贝构造
4. **remove vs erase**：remove删除所有匹配的元素，erase删除指定位置的元素

list容器特别适合需要频繁插入和删除操作的场景，因为它的这些操作都非常高效。