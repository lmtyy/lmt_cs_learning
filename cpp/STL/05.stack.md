好的，我们来详细讲解一下 C++ 标准库中的 `stack` 容器。

`stack`（栈）是一种遵循 **LIFO** 原则的容器适配器，即**后进先出**。最后插入的元素将是第一个被删除的。你可以把它想象成一叠盘子，你总是从最上面取走或放入盘子。

### 核心概念

1.  **容器适配器**：`stack` 并不是一个完整的、独立的容器，而是在其他序列容器（如 `deque`, `list`, `vector`）之上封装了一个特定的接口。默认情况下，它使用 `deque` 作为其底层容器。
2.  **LIFO**：这是栈的灵魂，所有操作都只在栈的“顶部”进行。

---

### 1. 头文件和定义

```cpp
#include <iostream>
#include <stack> // 必须包含 stack 头文件
// using namespace std; (根据你的要求，代码已包含)

int main() {
    // 定义一个存储 int 类型数据的栈
    stack<int> myStack;

    // 定义一个底层容器为 vector 的栈
    stack<int, vector<int>> myVectorStack;

    // 定义一个存储字符串的栈
    stack<string> nameStack;

    return 0;
}
```

---

### 2. 成员函数（核心操作）

栈的操作非常简洁，主要就是以下几个。

#### a. 元素访问

*   **`top()`**：返回栈顶元素的**引用**。这是你唯一能访问到的元素。

```cpp
stack<int> s;
s.push(10);
s.push(20);
s.push(30);

cout << "栈顶元素是: " << s.top() << endl; // 输出：30

// 你可以修改栈顶元素
s.top() = 100;
cout << "修改后栈顶元素是: " << s.top() << endl; // 输出：100
```

#### b. 容量查询

*   **`empty()`**：检查栈是否为空。为空返回 `true`，否则返回 `false`。
*   **`size()`**：返回栈中元素的数量。

```cpp
stack<int> s;
cout << "栈是否为空: " << s.empty() << endl; // 输出：1 (true)
cout << "栈的大小: " << s.size() << endl;   // 输出：0

s.push(1);
s.push(2);

cout << "栈是否为空: " << s.empty() << endl; // 输出：0 (false)
cout << "栈的大小: " << s.size() << endl;   // 输出：2
```

#### c. 修改操作

*   **`push(const T& value)`**：在栈顶插入一个元素。这是“压栈”操作。
*   **`emplace(Args&&... args)`**：在栈顶**就地构造**一个元素，避免了不必要的拷贝。对于自定义对象效率更高。
*   **`pop()`**：移除栈顶元素。注意：这个函数**不返回**被移除的元素。如果你需要这个元素，必须先使用 `top()` 获取它，然后再 `pop()`。

```cpp
stack<string> s;

// 使用 push
s.push("Apple");
s.push("Banana");

// 使用 emplace (直接在栈顶构造字符串)
s.emplace("Cherry");

// 现在栈内容从顶到底是： "Cherry" -> "Banana" -> "Apple"

// 正确的弹出方式
cout << "正在弹出: " << s.top() << endl; // 先获取
s.pop();                                 // 再移除

cout << "新的栈顶是: " << s.top() << endl; // 输出：Banana

// 错误的弹出方式！！！
// string fruit = s.pop(); // 错误！pop() 返回 void，不能赋值。
```

---

### 3. 完整示例

让我们看一个综合使用的例子：

```cpp
#include <iostream>
#include <stack>

using namespace std;

int main() {
    stack<int> numStack;

    // 压入数据
    cout << "压入数据: ";
    for (int i = 1; i <= 5; ++i) {
        cout << i << " ";
        numStack.push(i);
    }
    cout << endl;

    cout << "栈的大小: " << numStack.size() << endl;
    cout << "栈顶元素: " << numStack.top() << endl;

    // 弹出并显示所有元素 (经典的栈遍历方式)
    cout << "弹出数据: ";
    while (!numStack.empty()) {
        cout << numStack.top() << " "; // 查看栈顶
        numStack.pop();                // 移除栈顶
    }
    cout << endl;

    cout << "栈是否为空: " << numStack.empty() << endl;

    return 0;
}
```

**输出：**
```
压入数据: 1 2 3 4 5 
栈的大小: 5
栈顶元素: 5
弹出数据: 5 4 3 2 1 
栈是否为空: 1
```
这个例子完美展示了 LIFO 的特性：入栈顺序是 1,2,3,4,5，出栈顺序却是 5,4,3,2,1。

---

### 4. 底层容器

如前所述，`stack` 是适配器。你可以指定它的底层容器。默认是 `deque`，但你也可以使用 `list` 或 `vector`。

```cpp
#include <iostream>
#include <stack>
#include <vector>
#include <list>

using namespace std;

int main() {
    // 默认，使用 deque
    stack<int> stack1;

    // 显式指定使用 vector 作为底层容器
    stack<int, vector<int>> stack2;

    // 显式指定使用 list 作为底层容器
    stack<int, list<int>> stack3;

    // 它们的用法完全一样
    stack1.push(1);
    stack2.push(1);
    stack3.push(1);

    return 0;
}
```

**选择建议：**
*   **`deque` (默认)**：平衡性好，在大多数情况下是不错的选择。
*   **`vector`**：如果你非常关心内存局部性和访问速度，并且不介意在容量变化时可能发生的重新分配，可以使用它。
*   **`list`**：如果你需要保证在插入/删除时迭代器不失效，可以使用它。

---

### 5. 应用场景

栈在计算机科学中无处不在：
*   **函数调用栈**：这是栈最核心的应用，记录函数的调用层次和局部变量。
*   **表达式求值**（如中缀表达式转后缀表达式）。
*   **括号匹配检查**。
*   **撤销操作**：许多软件（如 Photoshop, Word）的撤销功能就是用栈实现的。
*   **深度优先搜索**：在图和树的遍历中。

### 括号匹配示例

这是一个栈的经典应用：

```cpp
#include <iostream>
#include <stack>

using namespace std;

bool isParenthesesValid(const string& s) {
    stack<char> stk;

    for (char c : s) {
        if (c == '(' || c == '[' || c == '{') {
            // 如果是左括号，压入栈中
            stk.push(c);
        } else {
            // 如果是右括号，检查栈是否为空
            if (stk.empty()) return false;
            // 检查栈顶的左括号是否与当前的右括号匹配
            char topChar = stk.top();
            if ((c == ')' && topChar != '(') ||
                (c == ']' && topChar != '[') ||
                (c == '}' && topChar != '{')) {
                return false;
            }
            // 匹配成功，弹出栈顶的左括号
            stk.pop();
        }
    }
    // 最后栈必须为空，才说明所有括号都匹配完毕
    return stk.empty();
}

int main() {
    string expr1 = "({[]})";
    string expr2 = "([)]";

    cout << expr1 << " 是否有效: " << (isParenthesesValid(expr1) ? "是" : "否") << endl;
    cout << expr2 << " 是否有效: " << (isParenthesesValid(expr2) ? "是" : "否") << endl;

    return 0;
}
```

**输出：**
```
({[]}) 是否有效: 是
([)] 是否有效: 否
```

### 总结

| 特性         | 说明                                        |
| :----------- | :------------------------------------------ |
| **原理**     | LIFO（后进先出）                            |
| **头文件**   | `#include <stack>`                          |
| **核心操作** | `push()`, `pop()`, `top()`                  |
| **容量查询** | `empty()`, `size()`                         |
| **高级操作** | `emplace()` (C++11)                         |
| **底层容器** | 默认 `deque`，可选 `vector`, `list`         |
| **关键点**   | `pop()` 不返回值，必须先 `top()` 再 `pop()` |

`stack` 是一个简单但极其强大的工具，它将复杂的数据操作简化为几个直观的函数，是每个 C++ 程序员必须熟练掌握的容器之一。