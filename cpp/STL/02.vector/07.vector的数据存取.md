好的，我们来详细讲解一下 C++ `vector` 的数据存取操作。`vector` 提供了多种方法来访问和修改其元素。

### 包含必要头文件
首先，使用 `vector` 需要包含其头文件。
```cpp
#include <vector>
#include <iostream> // 用于示例中的输出
using namespace std;
```

---

### 1. 使用下标运算符 `[ ]` (最常用)
这是最直接、最高效的访问方式，类似于访问普通数组。

*   **语法**: `vector_name[index]`
*   **特点**:
    *   **不检查索引是否越界**。如果索引 `index >= vector.size()`，行为是未定义的（通常导致程序崩溃或数据错误）。
    *   既可以读取元素的值，也可以修改元素的值（左值）。

```cpp
vector<int> vec = {10, 20, 30, 40, 50};

// 1. 读取元素
cout << "第一个元素: " << vec[0] << endl;   // 输出：10
cout << "第三个元素: " << vec[2] << endl;   // 输出：30

// 2. 修改元素
vec[1] = 200; // 将第二个元素从20改为200
cout << "修改后的第二个元素: " << vec[1] << endl; // 输出：200

// 3. 遍历vector
for (size_t i = 0; i < vec.size(); ++i) {
    cout << vec[i] << " ";
}
cout << endl; // 输出：10 200 30 40 50

// 危险！索引越界，未定义行为
// cout << vec[10] << endl; // 可能导致程序崩溃
```

---

### 2. 使用 `at()` 成员函数 (推荐用于安全性)
这是更安全的访问方式。

*   **语法**: `vector_name.at(index)`
*   **特点**:
    *   **会检查索引是否越界**。如果索引 `index >= vector.size()`，它会抛出一个 `std::out_of_range` 异常。
    *   同样可以用于读取和修改。

```cpp
vector<int> vec = {10, 20, 30, 40, 50};

// 1. 安全地读取和修改
cout << "使用at(): " << vec.at(2) << endl; // 输出：30
vec.at(3) = 400; // 安全修改

// 2. 安全遍历
for (size_t i = 0; i < vec.size(); ++i) {
    cout << vec.at(i) << " ";
}
cout << endl;

// 3. 捕获越界异常
try {
    cout << vec.at(100) << endl; // 试图访问不存在的元素
} catch (const out_of_range& e) {
    cerr << "发生异常: " << e.what() << endl; // 输出错误信息，程序不会崩溃
}
```

**`[ ]` 与 `at()` 如何选择？**
*   在追求极致性能且能 100% 保证索引不会越界的场景下（例如，循环变量 `i` 被严格控制在 `[0, size())` 范围内），使用 `[ ]`。
*   在大多数情况下，特别是当索引是计算出来的或来自用户输入时，使用 `at()` 更安全，能避免程序因越界而崩溃。

---

### 3. 访问第一个和最后一个元素
`vector` 提供了便捷的方法来直接访问首尾元素。

*   **`front()`**: 返回第一个元素的引用。
*   **`back()`**: 返回最后一个元素的引用。

```cpp
vector<int> vec = {10, 20, 30, 40, 50};

cout << "第一个元素: " << vec.front() << endl; // 等价于 vec[0] 或 vec.at(0)
cout << "最后一个元素: " << vec.back() << endl;  // 等价于 vec[vec.size()-1] 或 vec.at(vec.size()-1)

// 修改首尾元素
vec.front() = 1;
vec.back() = 99;

cout << "修改后第一个元素: " << vec.front() << endl; // 输出：1
cout << "修改后最后一个元素: " << vec.back() << endl;  // 输出：99
```

**注意**：在空vector上调用 `front()` 或 `back()` 是未定义行为。

---

### 4. 使用迭代器 (Iterator) 进行访问
迭代器提供了一种通用的方式来遍历容器，是 STL 算法的基石。

*   **`begin()`**: 返回指向第一个元素的迭代器。
*   **`end()`**: 返回指向**最后一个元素之后**的迭代器（尾后迭代器）。

```cpp
vector<int> vec = {10, 20, 30, 40, 50};

// 1. 使用迭代器遍历 (经典方式)
cout << "使用迭代器遍历: ";
for (vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
    cout << *it << " "; // 使用 * 操作符解引用迭代器以获取值
}
cout << endl;

// 2. 使用基于范围的for循环 (C++11, 更简洁，底层也是迭代器)
cout << "使用基于范围的for循环: ";
for (int value : vec) {
    cout << value << " ";
}
cout << endl;

// 3. 通过迭代器修改元素
for (vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
    *it *= 2; // 将每个元素的值乘以2
}

cout << "修改后的vector: ";
for (int value : vec) {
    cout << value << " ";
}
cout << endl;
```

---

### 5. 使用 `data()` 成员函数 (C++11)
这个方法返回一个指向底层数组的原始指针。这在需要与C风格API交互时非常有用。

*   **语法**: `vector_name.data()`
*   **特点**: 返回 `T*` 类型的指针。

```cpp
vector<int> vec = {10, 20, 30, 40, 50};

// 获取指向内部数组的指针
int* ptr = vec.data();

// 像使用普通数组一样使用指针
cout << "第一个元素: " << *ptr << endl;       // 输出：10
cout << "第二个元素: " << *(ptr + 1) << endl; // 输出：20
cout << "使用指针语法: " << ptr[2] << endl;   // 输出：30

// 修改元素
*(ptr + 3) = 999;
cout << "修改后的第四个元素: " << vec[3] << endl; // 输出：999
```

### 总结表格

| 方法       | 语法                       | 是否检查越界             | 主要用途                        |
| :--------- | :------------------------- | :----------------------- | :------------------------------ |
| 下标运算符 | `vec[index]`               | **否**                   | 快速、直接的访问，性能最高      |
| `at()`     | `vec.at(index)`            | **是**                   | 安全的访问，防止越界            |
| `front()`  | `vec.front()`              | **否**（空vector未定义） | 便捷访问第一个元素              |
| `back()`   | `vec.back()`               | **否**（空vector未定义） | 便捷访问最后一个元素            |
| 迭代器     | `vec.begin()`, `vec.end()` | -                        | 通用遍历，用于STL算法           |
| `data()`   | `vec.data()`               | -                        | 获取底层数组指针，用于C API交互 |

希望这个详细的讲解能帮助你全面掌握 C++ `vector` 的数据存取操作！