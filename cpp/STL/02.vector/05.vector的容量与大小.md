好的，我们来详细讲解一下 C++ `std::vector` 中**容量** 和**大小** 的核心概念与区别。这是理解 `vector` 高效工作的关键。

### 核心概念：一个生动的比喻

想象一个 `vector` 就像一个带预分配座位的剧院：

*   **大小**： 当前已经售出的票数，也就是剧院里实际坐了多少人。
    *   对应 `vector` 中 `size()` 成员函数返回的值。
*   **容量**： 剧院总共安装了多少个座位（包括空着的）。
    *   对应 `vector` 中 `capacity()` 成员函数返回的值。
*   **重新分配**： 当来的人超过座位数时，剧院经理会找一个更大的新剧院，把所有人和椅子都搬过去，并额外预留一些空座位以备后用。这个过程是**昂贵**的（耗时）。
    *   对应 `vector` 在容量不足时需要重新分配内存。

---

### 详细解释与对应的成员函数

#### 1. 大小

*   **`size()`**： 返回当前 `vector` 中实际包含的**元素数量**。如果 `vector` 为空，则 `size()` 返回 0。
*   **`empty()`**： 检查 `vector` 是否为空。它等价于 `size() == 0`，但可读性更好。

**操作大小的主要函数：**
*   **`push_back(val)`** / **`emplace_back(args...)`**： 在末尾添加一个元素，`size` 增加 1。
*   **`pop_back()`**： 移除末尾元素，`size` 减少 1。**容量不变**。
*   **`resize(n)`** / **`resize(n, val)`**： **直接改变大小**。
    *   如果 `n` 小于当前 `size`，多出的元素会被**销毁**。
    *   如果 `n` 大于当前 `size`，会添加新元素（使用 `val` 或默认值初始化）。这**可能导致容量增加**。

#### 2. 容量

*   **`capacity()`**： 返回当前 `vector` 在必须重新分配内存之前可以容纳的**元素总数**。`capacity() >= size()` 始终成立。
*   **`reserve(n)`**： 这是管理容量的**最关键函数**。它向 vector **“预订”至少能容纳 `n` 个元素的内存空间**。
    *   如果 `n` 大于当前 `capacity()`，则会进行**重新分配**，获得一块新的、更大的内存（容量至少为 `n`，可能更大，由编译器实现决定）。所有现有元素会被移动或复制到新内存，旧的被释放。
    *   如果 `n` 小于或等于当前 `capacity()`，则**什么也不做**。容量和大小都不会改变。

**为什么要有容量？**
为了避免每次 `push_back` 都重新分配内存。重新分配涉及分配新内存、复制元素、释放旧内存，成本很高。vector 的策略通常是：当容量不足时，会分配一个比当前需求更大的容量（例如，VS编译器下常见的是增长为当前的1.5倍，GCC下常见是2倍），这样后续的多次 `push_back` 就可以在不重新分配的情况下进行，从而摊平了成本。

#### 3. 压缩空间：`shrink_to_fit()`

*   这个函数是一个**非强制性请求**，要求 vector 将容量减少到刚好满足当前的大小（即 `capacity() = size()`）。
*   它旨在释放未使用的内存。但实现可以忽略这个请求，不过标准库的实现通常都会执行压缩。

---

### 代码示例

下面通过代码来演示这些概念。

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> vec; // 创建一个空的vector

    // 初始状态
    cout << "初始状态:" << endl;
    cout << "大小(size): " << vec.size() << endl;
    cout << "容量(capacity): " << vec.capacity() << endl;
    cout << "是否为空(empty): " << (vec.empty() ? "是" : "否") << endl;
    cout << "------------------------" << endl;

    // 添加一些元素，观察容量如何增长
    cout << "添加10个元素（观察容量增长）:" << endl;
    for (int i = 0; i < 10; ++i) {
        vec.push_back(i);
        // 注意：capacity() 的增长率取决于编译器实现
        cout << "push_back(" << i << ") -> size=" << vec.size() << ", capacity=" << vec.capacity() << endl;
    }
    cout << "------------------------" << endl;

    // 使用 reserve 预分配空间
    cout << "使用 reserve(100) 预分配空间:" << endl;
    vec.reserve(100);
    cout << "reserve(100)后 -> size=" << vec.size() << ", capacity=" << vec.capacity() << endl;
    cout << "------------------------" << endl;

    // 再添加元素，由于容量充足，不会重新分配
    cout << "再添加5个元素（不会重新分配）:" << endl;
    for (int i = 0; i < 5; ++i) {
        vec.push_back(i + 100);
    }
    cout << "添加后 -> size=" << vec.size() << ", capacity=" << vec.capacity() << endl;
    cout << "------------------------" << endl;

    // 使用 resize 改变大小
    cout << "使用 resize(5) 缩小vector:" << endl;
    vec.resize(5);
    cout << "resize(5)后 -> size=" << vec.size() << ", capacity=" << vec.capacity() << " (容量不变!)" << endl;
    cout << "------------------------" << endl;

    // 使用 shrink_to_fit 请求压缩空间
    cout << "使用 shrink_to_fit() 压缩空间:" << endl;
    vec.shrink_to_fit();
    cout << "shrink_to_fit()后 -> size=" << vec.size() << ", capacity=" << vec.capacity() << endl;
    cout << "------------------------" << endl;

    // 使用 resize 扩大vector（使用默认值0填充）
    cout << "使用 resize(8) 扩大vector:" << endl;
    vec.resize(8);
    for (const auto& num : vec) {
        cout << num << " ";
    }
    cout << endl;
    cout << "resize(8)后 -> size=" << vec.size() << ", capacity=" << vec.capacity() << endl;
    cout << "------------------------" << endl;

    // 使用 resize 扩大并指定填充值
    cout << "使用 resize(12, 42) 扩大并指定填充值:" << endl;
    vec.resize(12, 42); // 新增加的元素会被初始化为42
    for (const auto& num : vec) {
        cout << num << " ";
    }
    cout << endl;
    cout << "resize(12, 42)后 -> size=" << vec.size() << ", capacity=" << vec.capacity() << endl;

    return 0;
}
```

### 可能的输出（容量增长因编译器而异）:
```
初始状态:
大小(size): 0
容量(capacity): 0
是否为空(empty): 是
------------------------
添加10个元素（观察容量增长）:
push_back(0) -> size=1, capacity=1
push_back(1) -> size=2, capacity=2
push_back(2) -> size=3, capacity=4
push_back(3) -> size=4, capacity=4
push_back(4) -> size=5, capacity=8
push_back(5) -> size=6, capacity=8
push_back(6) -> size=7, capacity=8
push_back(7) -> size=8, capacity=8
push_back(8) -> size=9, capacity=16
push_back(9) -> size=10, capacity=16
------------------------
使用 reserve(100) 预分配空间:
reserve(100)后 -> size=10, capacity=100
------------------------
再添加5个元素（不会重新分配）:
添加后 -> size=15, capacity=100
------------------------
使用 resize(5) 缩小vector:
resize(5)后 -> size=5, capacity=100 (容量不变!)
------------------------
使用 shrink_to_fit() 压缩空间:
shrink_to_fit()后 -> size=5, capacity=5
------------------------
使用 resize(8) 扩大vector:
0 1 2 3 4 0 0 0 
resize(8)后 -> size=8, capacity=10
------------------------
使用 resize(12, 42) 扩大并指定填充值:
0 1 2 3 4 0 0 0 42 42 42 42 
resize(12, 42)后 -> size=12, capacity=12
```

### 总结与最佳实践

| 特性         | 大小                                    | 容量                       |
| :----------- | :-------------------------------------- | :------------------------- |
| **含义**     | 当前元素数量                            | 已分配内存可容纳的元素数量 |
| **获取函数** | `size()`                                | `capacity()`               |
| **改变函数** | `push_back()`, `pop_back()`, `resize()` | `reserve()`                |
| **关系**     | `size() <= capacity()`                  |                            |

**最佳实践：**

1.  **预分配是关键**：如果你事先知道 `vector` 最终会存放大量元素（例如 10000 个），请使用 `reserve(10000)`。这可以**避免多次重新分配**，极大提升性能。
2.  **`shrink_to_fit` 谨慎使用**：只在确定后续不会再添加大量元素，且需要节省内存时才使用。因为压缩本身也有成本（重新分配和移动）。
3.  **理解 `resize` 和 `reserve` 的区别**：
    *   `resize(n)` 改变的是**元素个数**。
    *   `reserve(n)` 改变的是**内存预算**，不创建新元素。