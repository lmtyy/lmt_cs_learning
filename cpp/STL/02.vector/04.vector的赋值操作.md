好的，在 C++ 中，`std::vector` 提供了多种灵活的方式来赋值。下面我将详细介绍所有主要的赋值操作，并为每种方法提供示例代码。

### 1. 初始化列表赋值 (C++11 起)
这是最直观的赋值方式，使用花括号 `{}` 直接提供初始值。

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    // 在声明时初始化
    vector<int> vec1 = {1, 2, 3, 4, 5};

    // 使用 assign 方法 with initializer list
    vector<int> vec2;
    vec2 = {10, 20, 30}; // 直接赋值
    // 或者
    vec2.assign({10, 20, 30}); // 使用 assign 方法

    // 打印 vec1
    cout << "vec1: ";
    for (int num : vec1) {
        cout << num << " ";
    }
    cout << endl;

    // 打印 vec2
    cout << "vec2: ";
    for (int num : vec2) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
```

### 2. 拷贝赋值
将一个 vector 的内容完全复制给另一个 vector。两个 vector 将包含独立的副本。

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> original = {1, 2, 3};
    vector<int> copy;

    // 拷贝赋值
    copy = original;

    // 修改 original 不会影响 copy
    original[0] = 99;

    cout << "original: ";
    for (int num : original) {
        cout << num << " "; // 输出: 99 2 3
    }
    cout << endl;

    cout << "copy: ";
    for (int num : copy) {
        cout << num << " "; // 输出: 1 2 3
    }
    cout << endl;

    return 0;
}
```

### 3. 移动赋值 (C++11 起)
将资源（内存所有权）从一个 vector“移动”到另一个 vector，原 vector 变为空。这通常更高效，因为它避免了不必要的拷贝。

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> source = {1, 2, 3, 4, 5};
    cout << "source (before move): ";
    for (int num : source) {
        cout << num << " ";
    }
    cout << " | size: " << source.size() << endl;

    vector<int> destination;
    // 移动赋值
    destination = move(source);

    cout << "destination (after move): ";
    for (int num : destination) {
        cout << num << " "; // 输出: 1 2 3 4 5
    }
    cout << " | size: " << destination.size() << endl;

    cout << "source (after move): ";
    for (int num : source) {
        cout << num << " "; // 可能没有输出，因为 source 现在为空
    }
    cout << " | size: " << source.size() << endl; // 输出: 0

    return 0;
}
```

### 4. 使用 `assign` 方法
`assign` 方法非常强大，它用新内容替换 vector 的所有元素。它有几种重载形式：

#### a) 使用迭代器范围
```cpp
#include <iostream>
#include <vector>
#include <list>

using namespace std;

int main() {
    list<int> myList = {10, 20, 30, 40, 50};
    vector<int> myVec;

    // 将 list 中的元素赋值给 vector
    myVec.assign(myList.begin(), myList.end());

    cout << "myVec: ";
    for (int num : myVec) {
        cout << num << " "; // 输出: 10 20 30 40 50
    }
    cout << endl;

    return 0;
}
```

#### b) 使用数量和初始值
```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> vec;

    // 创建包含 5 个元素（每个都是 100）的 vector
    vec.assign(5, 100);

    cout << "vec: ";
    for (int num : vec) {
        cout << num << " "; // 输出: 100 100 100 100 100
    }
    cout << endl;

    return 0;
}
```

### 5. 使用 `swap` 方法
`swap` 方法交换两个 vector 的内容。这是一种高效的 O(1) 操作。

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> vecA = {1, 2, 3};
    vector<int> vecB = {9, 8, 7, 6};

    cout << "Before swap:" << endl;
    cout << "vecA: ";
    for (int num : vecA) cout << num << " ";
    cout << endl;
    cout << "vecB: ";
    for (int num : vecB) cout << num << " ";
    cout << endl;

    // 交换两个 vector 的内容
    vecA.swap(vecB);
    // 也可以使用 std::swap(vecA, vecB);

    cout << "After swap:" << endl;
    cout << "vecA: ";
    for (int num : vecA) cout << num << " "; // 输出: 9 8 7 6
    cout << endl;
    cout << "vecB: ";
    for (int num : vecB) cout << num << " "; // 输出: 1 2 3
    cout << endl;

    return 0;
}
```

### 6. 使用 `insert` 方法
虽然 `insert` 主要用于在特定位置插入元素，但结合迭代器也可以实现赋值效果。

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> target = {0, 0, 0};
    vector<int> source = {7, 8, 9};

    // 清空 target 并插入 source 的所有内容
    target.clear();
    target.insert(target.begin(), source.begin(), source.end());

    cout << "target: ";
    for (int num : target) {
        cout << num << " "; // 输出: 7 8 9
    }
    cout << endl;

    return 0;
}
```

### 总结表格

| 方法                       | 描述                            | 关键点                                   |
| :------------------------- | :------------------------------ | :--------------------------------------- |
| **初始化列表 `={...}`**    | 使用花括号直接赋值              | C++11 起，直观简洁                       |
| **拷贝赋值 `=`**           | 复制另一个 vector 的内容        | 创建独立副本，操作后两个 vector 互不影响 |
| **移动赋值 `= move(...)`** | 转移另一个 vector 的内容        | C++11 起，高效，原 vector 变为空         |
| **`assign` 与迭代器**      | 将其他容器的元素范围赋给 vector | 非常灵活，可以从不同容器类型赋值         |
| **`assign(n, value)`**     | 创建 `n` 个值为 `value` 的元素  | 快速填充相同值                           |
| **`swap`**                 | 交换两个 vector 的内容          | O(1) 操作，高效                          |
| **`clear()` + `insert()`** | 清空后插入新内容                | 更灵活的插入方式，但不如 `assign` 直接   |

根据你的具体需求选择最合适的方法。对于简单的初始化，使用初始化列表；需要高效转移资源时用移动赋值；需要完全替换内容时，`assign` 方法通常是最佳选择。