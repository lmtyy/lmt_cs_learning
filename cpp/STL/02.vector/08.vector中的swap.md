好的，我们来详细讲解一下 C++ 中 `std::vector` 的 `swap` 成员函数，它的应用场景，并提供完整的代码示例。

### 1. swap 的基本概念

`std::vector` 的 `swap` 成员函数用于交换两个同类型向量的**所有内容**。这里的“所有内容”主要指三个方面：
1.  **底层数据指针**：指向实际存储元素的数组的指针。
2.  **大小（size）**：当前容器中元素的数量。
3.  **容量（capacity）**：容器在必须分配新存储空间之前可以容纳的元素数量。

它的函数原型是：
```cpp
void swap(vector& other);
```

**关键特性：**
*   **高效**：交换操作的时间复杂度是**常数时间 O(1)**。因为它只交换了内部的指针和几个成员变量（如 size, capacity），而**不是**逐个元素地复制或移动。无论向量有多大，交换速度都非常快。
*   **无迭代器失效**：交换后，原本指向容器 A 中元素的迭代器、指针和引用现在指向容器 B 中的元素，反之亦然。它们仍然有效，只是所属的容器变了。

---

### 2. swap 的应用场景

`swap` 的强大之处在于其高效性，常用于解决性能问题或实现特定技巧。

#### 应用 1：高效地清空一个向量

如果你想清空一个向量并释放其占用的所有内存（即容量也变为 0），使用 `v.clear()` 是没用的，因为 `clear()` 只销毁元素并将 size 设为 0，但**容量（capacity）通常保持不变**。

**技巧：** 与一个空的临时向量进行交换。
一个空的临时向量在交换后获得了原向量的所有容量，而原向量则变成了一个真正空的向量（size 和 capacity 都为 0）。当临时向量离开作用域时，其析构函数会释放掉那块大内存。

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> vec = {1, 2, 3, 4, 5};
    cout << "清空前 - Size: " << vec.size() << ", Capacity: " << vec.capacity() << endl;

    // 错误的做法：clear() 不释放容量
    // vec.clear();
    // cout << "使用clear后 - Size: " << vec.size() << ", Capacity: " << vec.capacity() << endl;

    // 正确的做法：使用 swap 技巧
    vector<int>().swap(vec); // 创建一个匿名空向量，与 vec 交换

    cout << "使用swap清空后 - Size: " << vec.size() << ", Capacity: " << vec.capacity() << endl;

    return 0;
}
```

**输出：**
```
清空前 - Size: 5, Capacity: 5
使用swap清空后 - Size: 0, Capacity: 0
```

#### 应用 2：高效地缩小向量容量（Shrink-to-Fit）

有时你从向量中删除了很多元素，导致 `size` 远小于 `capacity`，造成内存浪费。C++11 引入了 `shrink_to_fit()` 成员函数来请求减少容量，但这不是强制性的。

使用 `swap` 是 C++11 之前实现 “shrink-to-fit” 的经典且可靠的方法。

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> vec;
    vec.reserve(100); // 预先分配 100 个元素的容量
    for (int i = 0; i < 10; ++i) {
        vec.push_back(i);
    }
    cout << "操作后 - Size: " << vec.size() << ", Capacity: " << vec.capacity() << endl;

    // 方法1：C++11 的 shrink_to_fit（推荐）
    // vec.shrink_to_fit();

    // 方法2：使用 swap 技巧
    vector<int>(vec).swap(vec); // 关键步骤

    cout << "缩小容量后 - Size: " << vec.size() << ", Capacity: " << vec.capacity() << endl;

    return 0;
}
```

**解释 `vector<int>(vec).swap(vec)`：**
1.  `vector<int>(vec)`：使用拷贝构造函数创建一个新的临时向量。这个新向量的 `size` 和 `capacity` 都等于原向量 `vec` 的 `size`。
2.  `.swap(vec)`：将这个新的、容量刚好的临时向量与 `vec` 交换。
3.  交换后，`vec` 变成了容量刚好的向量，而临时向量拥有了原来巨大的容量。
4.  临时向量在语句结束后立即被销毁，释放了多余的内存。

**输出：**
```
操作后 - Size: 10, Capacity: 100
缩小容量后 - Size: 10, Capacity: 10
```

#### 应用 3：快速交换两个大向量的内容

当你需要交换两个包含大量数据的向量时，使用 `swap` 是最高效的方式。如果使用拷贝赋值（`v1 = v2`），代价会非常高昂（O(n)），而 `swap` 是常数时间。

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> v1 = {1, 2, 3, 4, 5};
    vector<int> v2 = {10, 20, 30};

    cout << "交换前：" << endl;
    cout << "v1: ";
    for (int num : v1) cout << num << " ";
    cout << endl;
    cout << "v2: ";
    for (int num : v2) cout << num << " ";
    cout << endl;

    // 高效交换
    v1.swap(v2); // 也可以使用 std::swap(v1, v2);

    cout << "\n交换后：" << endl;
    cout << "v1: ";
    for (int num : v1) cout << num << " ";
    cout << endl;
    cout << "v2: ";
    for (int num : v2) cout << num << " ";
    cout << endl;

    return 0;
}
```

**输出：**
```
交换前：
v1: 1 2 3 4 5
v2: 10 20 30

交换后：
v1: 10 20 30
v2: 1 2 3 4 5
```

---

### 3. 注意：std::swap 与成员函数 swap

标准库在 `<utility>` 头文件中提供了一个通用的 `std::swap` 函数模板。对于 `std::vector` 这样的标准容器，`std::swap` 已经被特化，其内部实现就是调用容器自己的 `swap` 成员函数。

所以，以下两种写法是等价的，并且效率相同：
```cpp
v1.swap(v2);       // 成员函数版本
std::swap(v1, v2); // 非成员函数版本，推荐，更符合通用编程风格
```

**最佳实践：** 在日常代码中，更推荐使用 `std::swap(v1, v2)`，因为它更通用，可以用于交换任何支持移动语义或具有高效特化版本的类型。

### 总结

| 特性/应用      | 描述                                                         |
| :------------- | :----------------------------------------------------------- |
| **核心机制**   | 交换内部指针、大小和容量，时间复杂度为 **O(1)**。            |
| **迭代器**     | 交换后，迭代器、指针和引用会跟随元素交换到另一个容器，但仍然有效。 |
| **清空向量**   | `vector<T>().swap(v)` 可以高效清空向量并释放所有内存。       |
| **缩小容量**   | `vector<T>(v).swap(v)` 是 C++11 前实现 “shrink-to-fit” 的可靠方法。 |
| **交换大容器** | 交换两个大容器内容时的最佳选择，避免高昂的拷贝成本。         |
| **使用方式**   | 优先使用 `std::swap(v1, v2)`，它与成员函数 `v1.swap(v2)` 等效且更通用。 |

希望这个详细的解释和代码示例能帮助你彻底理解 `vector::swap` 的用法和威力！