好的，我们来详细讲讲 C++ STL 中的 `vector`。它是 STL 中最常用、最重要的容器之一。

### 1. vector 是什么？

`vector` 是一个**动态数组**。它拥有普通数组的所有特性，但增加了一个强大的功能：**可以动态地改变大小**。

*   **底层本质**：它在内存中是一段**连续存储**的数组。这意味着你可以像普通数组一样通过下标（`[]`）来随机访问元素，效率极高（O(1) 时间复杂度）。
*   **动态增长**：当新元素插入导致容量不足时，`vector` 会自动分配一个更大的内存块（通常是当前容量的 1.5 或 2 倍），将原有元素“搬家”过去，然后释放旧内存。这个过程对用户是透明的。
*   **属于序列式容器**：元素在容器中的位置顺序与它们被插入的顺序严格对应。

### 2. 为什么要使用 vector？

相比于原始数组和 C++ 的其他容器，`vector` 有诸多优点：

1.  **动态大小**：无需在编译时指定大小，可以运行时动态添加/删除元素。解决了原始数组固定大小的痛点。
2.  **随机访问**：通过索引访问元素的速度极快，与原始数组相当。
3.  **内存管理自动化**：自动处理内存的分配和释放，避免了手动 `new/delete` 可能带来的内存泄漏问题。
4.  **丰富的成员函数**：提供了大量方便的方法，如 `push_back`, `pop_back`, `insert`, `erase`, `size`, `empty` 等。
5.  **与算法完美配合**：可以与 STL 算法（如 `sort`, `find`, `copy` 等）无缝协作。

**缺点**：
*   在中间或头部插入/删除元素效率较低（O(n) 时间复杂度），因为需要移动后续的所有元素。如果需要频繁在头部操作，应考虑 `deque` 或 `list`。
*   动态扩容时可能会造成一定的性能开销（内存分配和元素拷贝/移动）。但通过 `reserve()` 可以缓解。

### 3. 基本用法

#### 头文件和命名空间
```cpp
#include <vector>
using namespace std; // 或者使用 std::vector
```

#### 声明和初始化
```cpp
// 1. 创建一个空的 vector
vector<int> vec1;

// 2. 创建指定大小的 vector，元素初始化为默认值（int 为 0）
vector<int> vec2(5); // 包含 5 个 0

// 3. 创建指定大小并初始化所有元素为特定值
vector<int> vec3(5, 10); // 包含 5 个 10

// 4. 通过初始化列表 (C++11)
vector<int> vec4 = {1, 2, 3, 4, 5};
vector<int> vec5 {6, 7, 8};

// 5. 通过另一个数组或 vector 初始化
int arr[] = {1, 2, 3};
vector<int> vec6(arr, arr + 3); // 使用迭代器范围
vector<int> vec7(vec4.begin(), vec4.end()); // 拷贝 vec4
vector<int> vec8(vec4); // 拷贝构造
```

#### 常用操作

**1. 访问元素**
```cpp
vector<int> v = {10, 20, 30};

// 使用下标运算符 [] (不检查边界，访问越界是未定义行为)
cout << v[0] << endl; // 10
v[1] = 100; // 修改元素

// 使用 at() 成员函数 (会检查边界，越界抛出 std::out_of_range 异常)
cout << v.at(2) << endl; // 30
// v.at(5); // 会抛出异常

// 访问第一个和最后一个元素
cout << v.front() << endl; // 10
cout << v.back() << endl;  // 30

// 获取底层数据的指针（用于需要 C 风格数组的接口）
int* data_ptr = v.data();
```

**2. 添加元素**
```cpp
vector<int> v;

// 在末尾添加元素 (最常用，平均时间复杂度 O(1))
v.push_back(1);
v.push_back(2);
v.push_back(3); // v: {1, 2, 3}

// 在指定位置插入元素 (效率较低，O(n))
auto it = v.begin() + 1; // 迭代器指向第二个元素之前
v.insert(it, 99); // v: {1, 99, 2, 3}

// C++11: 原地构造，避免拷贝，效率更高
v.emplace_back(4); // 在末尾直接构造一个 4
v.emplace(v.begin(), 0); // 在开头直接构造一个 0
```

**3. 删除元素**
```cpp
vector<int> v = {0, 1, 99, 2, 3, 4, 3};

// 删除末尾元素 (O(1))
v.pop_back(); // v: {0, 1, 99, 2, 3, 4}

// 删除指定位置的元素 (O(n))
v.erase(v.begin() + 2); // 删除第三个元素 (99) -> v: {0, 1, 2, 3, 4}

// 删除一个范围内的元素 [first, last)
v.erase(v.begin() + 1, v.begin() + 3); // 删除第2到第3个元素 -> v: {0, 3, 4}

// 删除所有元素 (清空vector，size变为0，capacity不变)
v.clear();

// 删除所有值等于特定值的元素 (需要配合算法，O(n))
vector<int> v2 = {1, 2, 3, 2, 4};
v2.erase(remove(v2.begin(), v2.end(), 2), v2.end()); // v2: {1, 3, 4}
```

**4. 获取大小和容量**
```cpp
vector<int> v = {1, 2, 3};

// size(): 当前拥有的元素个数
cout << v.size() << endl; // 3

// capacity(): 当前分配的内存可以容纳的元素总数 (>= size)
cout << v.capacity() << endl; // 可能为 4, 8 等

// empty(): 判断 vector 是否为空
cout << v.empty() << endl; // 0 (false)

// resize(n): 改变元素个数
v.resize(5);     // 将大小改为5，新增的元素初始化为0 -> {1, 2, 3, 0, 0}
v.resize(2);     // 将大小改为2，丢弃后面的元素 -> {1, 2}

// reserve(n): 预留内存空间，避免多次重新分配
v.reserve(100); // 提前分配至少能容纳100个元素的内存
```

### 4. 迭代器

迭代器用于遍历 `vector`，类似于指针。
```cpp
vector<int> v = {10, 20, 30};

// 1. 使用迭代器遍历
for (vector<int>::iterator it = v.begin(); it != v.end(); ++it) {
    cout << *it << " ";
}
// C++11 后使用 auto 简化
for (auto it = v.begin(); it != v.end(); ++it) {
    cout << *it << " ";
}

// 2. 使用范围基于的 for 循环 (最简洁，C++11)
for (const auto& value : v) {
    cout << value << " ";
}

// 3. 反向迭代器
for (auto rit = v.rbegin(); rit != v.rend(); ++rit) {
    cout << *rit << " "; // 输出: 30 20 10
}
```

### 5. 重要特性与技巧

1.  **迭代器失效**：当对 `vector` 进行添加或删除操作时，可能会引起内存重新分配，从而导致之前获取的迭代器、指针或引用失效。**在修改操作后，应重新获取迭代器**。
    ```cpp
    vector<int> v = {1, 2, 3, 4};
    auto it = v.begin() + 2; // 指向 3
    v.push_back(5); // 可能导致扩容，it 失效！
    // *it; // 错误！未定义行为
    ```

2.  **`shrink_to_fit()` (C++11)**：请求容器移除未使用的容量，将 `capacity()` 减少到与 `size()` 匹配。这是一个**非强制性**的请求，实现可以选择忽略。
    ```cpp
    vector<int> v(1000);
    v.resize(10); // size=10, capacity 可能还是 1000+
    v.shrink_to_fit(); // 请求释放多余内存，capacity 可能变为 10
    ```

### 总结

| 特性                   | 描述                                                         |
| :--------------------- | :----------------------------------------------------------- |
| **核心**               | 动态数组，连续内存存储                                       |
| **访问**               | 随机访问，O(1) 时间复杂度                                    |
| **尾部插入/删除**      | 平均 O(1) 时间复杂度                                         |
| **中间/头部插入/删除** | O(n) 时间复杂度                                              |
| **大小调整**           | 自动管理，可手动 `reserve()` 优化                            |
| **适用场景**           | 需要频繁随机访问，大部分操作在尾部进行的情况（如栈、动态列表） |

`vector` 是 C++ 中效率和便利性兼顾得最好的容器之一，是大多数情况下的首选序列容器。理解其底层原理和特性，能帮助你写出更高效、更安全的代码。