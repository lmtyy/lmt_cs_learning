好的，我们来详细讲解一下 C++ 中结构体作为函数参数的各种方式、区别以及最佳实践。

在 C++ 中，结构体（`struct`）在作为函数参数传递时，主要有三种方式：
1.  按值传递
2.  按引用传递
3.  按指针传递

选择哪种方式取决于你的具体需求：是否需要修改原始结构体、对性能的要求以及代码的可读性。

---

### 1. 按值传递

这是最直接的方式。函数接收的是原始结构体的一份**副本**。

**语法：**
```cpp
returnType functionName(StructType paramName);
```

**示例：**
```cpp
#include <iostream>
using namespace std;

struct Point {
    int x;
    int y;
};

// 按值传递的函数
void printPoint(Point p) { // 'p' 是原始结构体的一个副本
    cout << "X: " << p.x << ", Y: " << p.y << endl;
    // 修改副本不会影响原始数据
    p.x = 100;
}

int main() {
    Point p1 = {10, 20};
    printPoint(p1); // 输出: X: 10, Y: 20
    cout << "After function call, original p1.x is still: " << p1.x << endl; // 输出: 10
    return 0;
}
```

**特点：**
*   **优点**：简单安全。函数内部对参数的任何修改都不会影响原始数据。
*   **缺点**：**性能开销大**。当结构体很大（包含很多成员）时，复制整个结构体会消耗较多的时间和内存。

**适用场景**：小型结构体，且函数不需要修改原始数据。

---

### 2. 按引用传递

函数接收的是原始结构体的一个**别名**（alias），操作的就是原始数据本身。

**语法：**
```cpp
returnType functionName(StructType &paramName); // 非常量引用
returnType functionName(const StructType &paramName); // 常量引用
```

#### A. 非常量引用

用于需要修改原始结构体内容的场景。

**示例：**
```cpp
// 按非常量引用传递的函数
void movePoint(Point &p, int deltaX, int deltaY) { // 'p' 是原始结构体的一个引用
    p.x += deltaX; // 直接修改原始数据
    p.y += deltaY;
}

int main() {
    Point p1 = {10, 20};
    movePoint(p1, 5, 5);
    cout << "After movePoint, p1 is: X: " << p1.x << ", Y: " << p1.y << endl; // 输出: X: 15, Y: 25
    return 0;
}
```

#### B. 常量引用

用于不需要修改原始结构体，只想读取其值的场景。这是**最常用、最推荐**的只读传递方式。

**示例：**
```cpp
// 按常量引用传递的函数
void printPoint(const Point &p) { // 'p' 是原始结构体的一个只读引用
    cout << "X: " << p.x << ", Y: " << p.y << endl;
    // p.x = 100; // 错误！编译器会报错，因为 p 是 const 的，不能被修改
}

int main() {
    Point p1 = {10, 20};
    printPoint(p1); // 效率高，且安全
    return 0;
}
```

**特点：**
*   **优点**：
    *   **零开销**：没有复制操作，性能极高，无论结构体多大。
    *   **可修改性**（非常量引用）：可以直接修改原始数据。
    *   **安全性**（常量引用）：使用 `const` 保证函数内部不会意外修改数据。
*   **缺点**：
    *   （非常量引用）函数内部的修改会影响原始数据，这可能不是你想要的效果。

**适用场景**：
*   **`const &`**：几乎所有不需要修改结构体的场景。
*   **`&`**：需要修改原始结构体的场景。

---

### 3. 按指针传递

函数接收的是原始结构体的**内存地址**。你需要使用解引用操作符 `->` 或 `*` 来访问成员。

**语法：**
```cpp
returnType functionName(StructType *paramName); // 非常量指针
returnType functionName(const StructType *paramName); // 指向常量对象的指针
```

#### A. 非常量指针

**示例：**
```cpp
// 按指针传递的函数
void scalePoint(Point *ptr, int scale) { // ‘ptr' 存储的是 Point 对象的地址
    if (ptr != nullptr) { // 良好的习惯：总是检查指针是否有效
        ptr->x *= scale; // 使用 -> 操作符访问成员
        ptr->y *= scale;
        // 等价于: (*ptr).x *= scale;
    }
}

int main() {
    Point p1 = {10, 20};
    scalePoint(&p1, 2); // 使用取地址操作符 & 传递地址
    cout << "After scalePoint, p1 is: X: " << p1.x << ", Y: " << p1.y << endl; // 输出: X: 20, Y: 40
    return 0;
}
```

#### B. 指向常量的指针

**示例：**
```cpp
void printPoint(const Point *ptr) {
    if (ptr != nullptr) {
        cout << "X: " << ptr->x << ", Y: " << ptr->y << endl;
    }
}
```

**特点：**
*   **优点**：
    *   性能高，只传递一个地址（通常是 4 或 8 字节）。
    *   可以修改原始数据（非常量指针）。
    *   可以接受 `nullptr`，表示“无对象”（但函数内部需要处理这种情况）。
*   **缺点**：
    *   语法稍显复杂，需要使用 `->` 和 `&`。
    *   存在指针为空的风险，必须小心处理，否则会导致程序崩溃。

**适用场景**：
*   需要修改原始数据，且该参数有可能为“空”或“可选”时。
*   与 C 语言代码交互时（C 中没有引用）。
*   操作动态分配的结构体（如使用 `new` 创建的）时，指针是必然的选择。

---

### 总结与对比

| 传递方式 | 语法示例 | 是否修改原数据 | 性能 | 安全性 | 主要适用场景 |
| ：--- | :--- | :--- | :--- | :--- | :--- |
| **按值传递** | `void func(Point p);` | **否** | 差（复制开销） | 高（原始数据安全） | 小型结构体，且不需修改 |
| **按引用传递** | `void func(Point &p);` | **是** | **优**（无复制） | 需注意（可修改原数据） | **需要修改**原始数据 |
| **按常量引用传递** | `void func(const Point &p);` | **否** | **优**（无复制） | **高**（原数据只读） | **不需要修改**原始数据（**首选**） |
| **按指针传递** | `void func(Point *p);` | **是**（需解引用） | **优**（传地址） | 需注意（需检查空指针） | 需修改，且参数可能为空 |
| **按常量指针传递** | `void func(const Point *p);` | **否** | **优**（传地址） | 需注意（需检查空指针） | 不需修改，且参数可能为空 |

### 最佳实践建议

1.  **默认使用 `const &`**：如果你的函数只需要读取结构体的值而不修改它，**总是优先使用常量引用**（`const StructType &`）。这是性能和安全性的最佳结合。

2.  **需要修改时使用 `&`**：如果你的函数需要修改调用者传来的结构体对象，使用非常量引用。它比指针更安全、语法更清晰。

3.  **谨慎使用指针**：只有当参数确实是“可选”的（即可以为 `nullptr`），或者你需要处理动态内存分配的对象时，才使用指针。现代 C++ 中，引用的使用优先级高于指针。

4.  **避免按值传递大型结构体**：对于任何包含较多数据成员的结构体或类，都应避免按值传递，以免造成不必要的性能损失。

5.  **C++ 与 C 的区别**：在 C 语言中，只有值和指针两种方式，引用是 C++ 特有的。在 C++ 中，引用通常比指针更受欢迎，因为它更安全、更直观。

希望这个详细的解释能帮助你更好地理解和使用结构体参数！