问得非常好！类模板和函数模板虽然都基于相同的模板概念，但在使用和行为上有一些重要的区别。

## 核心区别对比表

| 特性           | 类模板 (Class Template)       | 函数模板 (Function Template) |
| :------------- | :---------------------------- | :--------------------------- |
| **实例化方式** | 必须显式或隐式指定模板参数    | 通常可以自动推导模板参数     |
| **参数推导**   | 不支持自动类型推导（C++17前） | 支持强大的自动类型推导       |
| **使用语法**   | `ClassName<Type> obj;`        | `functionName(arguments);`   |
| **特化**       | 支持全特化和偏特化            | 只支持全特化，不支持偏特化   |
| **默认参数**   | 支持默认模板参数              | 支持默认模板参数（C++11+）   |
| **CTAD**       | C++17 支持类模板实参推导      | 从一开始就支持参数推导       |

---

## 详细区别解析

### 1. 模板参数推导 (Template Argument Deduction)

这是最显著的区别！

**函数模板 - 强大的自动推导**
```cpp
template <typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    int result1 = max(10, 20);      // 正确！T 被推导为 int
    double result2 = max(3.14, 2.71); // 正确！T 被推导为 double
    // auto result3 = max(10, 3.14);  // 错误！T 无法推导（一个int，一个double）
    
    return 0;
}
```

**类模板 - 需要显式指定或有限推导**
```cpp
template <typename T>
class Box {
    T value;
public:
    Box(T v) : value(v) {}
};

int main() {
    // C++17 之前：必须显式指定类型
    Box<int> box1(42);          // 正确
    // Box box2(42);            // C++17 前：错误！需要模板参数
    
    // C++17 及之后：支持类模板实参推导 (CTAD)
    Box box3(42);               // C++17+：正确！T 推导为 int
    Box box4(3.14);             // C++17+：正确！T 推导为 double
    
    return 0;
}
```

### 2. 特化 (Specialization) 的支持程度不同

**类模板 - 支持全特化和偏特化**
```cpp
// 通用模板
template <typename T1, typename T2>
class Pair { /*...*/ };

// 全特化
template <>
class Pair<int, double> { /* 特殊实现 */ };

// 偏特化：当两个类型相同时
template <typename T>
class Pair<T, T> { /* 特殊实现 */ };

// 偏特化：针对指针类型
template <typename T1, typename T2>
class Pair<T1*, T2*> { /* 特殊实现 */ };
```

**函数模板 - 只支持全特化**
```cpp
// 通用模板
template <typename T>
void process(T value) { /*...*/ }

// 全特化：允许
template <>
void process<int>(int value) { /* 特殊处理 int */ }

// 偏特化：不允许！
// template <typename T>
// void process<T*>(T* value) { /* 这会编译错误 */ }

// 替代方案：使用函数重载
template <typename T>
void process(T* value) { /* 处理指针的重载版本 */ }
```

### 3. 默认模板参数 (Default Template Arguments)

两者都支持，但使用场景不同。

**类模板 - 广泛使用默认参数**
```cpp
template <typename T = int, int Size = 10>
class Array {
    T data[Size];
    // ...
};

Array<> arr1;        // 使用默认参数：Array<int, 10>
Array<double> arr2;  // 使用默认Size：Array<double, 10>
```

**函数模板 - 默认参数使用较少**
```cpp
template <typename T = int>
T create() {
    return T();
}

int main() {
    auto x = create();       // 返回 int(0)，使用默认 int
    auto y = create<double>(); // 返回 double(0.0)
    return 0;
}
```

### 4. 使用模式和场景

**类模板 - 创建类型**
- 用于定义新的类型家族
- 通常表示数据结构或容器
- 实例化后是一个具体的类

```cpp
// 数据结构家族
vector<int> vi;
vector<double> vd;
list<string> ls;

// 智能指针家族
shared_ptr<MyClass> sp;
unique_ptr<MyClass> up;
```

**函数模板 - 定义算法操作**
- 用于定义操作家族
- 通常表示算法或函数
- 调用时生成具体的函数

```cpp
// 算法家族
sort(vec.begin(), vec.end());
copy(src.begin(), src.end(), dest.begin());
max(a, b);
```

### 5. 实参推导的复杂性

**函数模板 - 复杂的推导规则**
```cpp
template <typename T>
void func(T param) {}

int main() {
    int x = 10;
    const int cx = x;
    const int& rx = x;
    
    func(x);    // T = int, param = int
    func(cx);   // T = int, param = int (const 被丢弃)
    func(rx);   // T = int, param = int (引用和const被丢弃)
    
    return 0;
}
```

**类模板 - 简单的推导（C++17 CTAD）**
```cpp
template <typename T>
class Wrapper {
public:
    Wrapper(T v) : value(v) {}
private:
    T value;
};

int main() {
    int x = 10;
    const int cx = x;
    
    Wrapper w1(x);   // T = int
    Wrapper w2(cx);  // T = int (const 被丢弃)
    
    return 0;
}
```

---

## 实际代码示例对比

### 相同的模板概念，不同的使用方式

```cpp
#include <iostream>
#include <vector>

// 函数模板 - 算法
template <typename T>
T findMax(const std::vector<T>& vec) {
    T max = vec[0];
    for (const auto& item : vec) {
        if (item > max) max = item;
    }
    return max;
}

// 类模板 - 数据结构
template <typename T>
class MaxTracker {
private:
    T currentMax;
public:
    MaxTracker(T initial) : currentMax(initial) {}
    
    void update(T value) {
        if (value > currentMax) currentMax = value;
    }
    
    T getMax() const { return currentMax; }
};

int main() {
    std::vector<int> numbers = {1, 5, 3, 9, 2};
    
    // 使用函数模板 - 自动推导
    int max1 = findMax(numbers);
    std::cout << "Function template result: " << max1 << std::endl;
    
    // 使用类模板 - 需要指定类型（C++17前）
    MaxTracker<int> tracker(numbers[0]);
    for (const auto& num : numbers) {
        tracker.update(num);
    }
    std::cout << "Class template result: " << tracker.getMax() << std::endl;
    
    // C++17 可以使用推导
    MaxTracker tracker2(numbers[0]); // CTAD 推导为 MaxTracker<int>
    
    return 0;
}
```

---

## 总结

1. **推导能力**：函数模板有强大的自动类型推导，类模板需要显式指定或依赖CTAD（C++17+）
2. **特化支持**：类模板支持全特化和偏特化，函数模板只支持全特化
3. **使用场景**：类模板用于创建类型家族，函数模板用于定义算法操作
4. **默认参数**：两者都支持，但在类模板中更常见
5. **语法差异**：类模板实例化需要 `<>`，函数模板通常不需要

**简单记法：**
- **类模板**：像是创建各种尺寸和材料的"盒子"
- **函数模板**：像是能处理各种类型数据的"万能工具"

理解这些区别有助于你在合适的场景选择合适的技术，写出更优雅和高效的C++代码。