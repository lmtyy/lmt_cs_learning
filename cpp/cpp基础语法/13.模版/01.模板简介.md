好的，我们来详细介绍一下 C++ 中的模板（Template）。

### 什么是模板？

模板是 C++ 中支持**泛型编程**（Generic Programming）的核心工具。它允许你编写与数据类型无关的通用代码，是一种“代码生成”的蓝图。你可以把它想象成一个**模具**。

*   **没有模板的情况**：如果你需要实现一个交换两个 `int` 值的函数，后来又需要交换两个 `double` 值的函数，你必须写两个几乎一模一样的重载函数。
*   **有模板的情况**：你只需要写一个“函数模板”，编译器会根据你使用模板时提供的具体类型，自动为你生成处理 `int`, `double`, `string` 等类型的代码。

模板的核心思想是：**将数据类型参数化**。

---

### 为什么需要模板？

1.  **代码复用**：编写一次模板，即可用于多种数据类型，大大减少了代码冗余。
2.  **类型安全**：与 C 语言中的 `void*` 宏函数等方式相比，模板是类型安全的。编译器会在编译期进行类型检查，生成的代码是强类型的。
3.  **性能**：模板是在编译期实例化的，生成的代码与手写代码效率相同，没有任何运行时开销（零开销抽象）。
4.  **强大的抽象能力**：是标准模板库（STL）和元编程的基础。

---

### 模板的种类

主要分为两类：**函数模板** 和 **类模板**。

#### 1. 函数模板（Function Template）

用于创建通用函数的家族。

**语法：**
```cpp
template <typename T> // 或者 template <class T>
返回类型 函数名(参数列表) {
    // 函数体
}
```
*   `template`: 关键字，表示开始一个模板声明。
*   `<typename T>`: 模板参数列表。`T` 是一个占位符，代表一种未知的类型（称为“模板类型参数”）。你可以使用任何标识符（如 `MyType`, `Elem`），但 `T` 是惯例。
    *   `typename` 和 `class` 在这里可以互换使用，`typename` 更现代也更直观。

**示例：交换函数**
```cpp
#include <iostream>
using namespace std;

// 声明一个函数模板
template <typename T>
void mySwap(T &a, T &b) {
    T temp = a;
    a = b;
    b = temp;
}

int main() {
    int i1 = 10, i2 = 20;
    double d1 = 1.1, d2 = 2.2;
    char c1 = 'A', c2 = 'B';

    // 使用函数模板
    // 编译器会自动推导类型，生成 mySwap<int>(i1, i2);
    mySwap(i1, i2);
    cout << "i1: " << i1 << ", i2: " << i2 << endl;

    // 生成 mySwap<double>(d1, d2);
    mySwap(d1, d2);
    cout << "d1: " << d1 << ", d2: " << d2 << endl;

    // 也可以显式指定类型
    mySwap<char>(c1, c2);
    cout << "c1: " << c1 << ", c2: " << c2 << endl;

    return 0;
}
```

#### 2. 类模板（Class Template）

用于创建通用类的家族。STL 中的容器（如 `vector`, `list`, `map`）都是类模板。

**语法：**
```cpp
template <typename T> // 或者 template <class T>
class 类名 {
    // 类成员定义
};
```

**示例：一个简单的栈类**
```cpp
#include <iostream>
#include <vector>
using namespace std;

template <typename T>
class Stack {
private:
    vector<T> elements; // 使用 vector 作为底层容器

public:
    void push(const T &value) {
        elements.push_back(value);
    }

    void pop() {
        if (isEmpty()) {
            throw out_of_range("Stack<>::pop(): empty stack");
        }
        elements.pop_back();
    }

    T top() const {
        if (isEmpty()) {
            throw out_of_range("Stack<>::top(): empty stack");
        }
        return elements.back();
    }

    bool isEmpty() const {
        return elements.empty();
    }
};

int main() {
    // 使用类模板必须显式指定类型
    Stack<int> intStack;
    intStack.push(1);
    intStack.push(2);
    cout << intStack.top() << endl; // 输出 2
    intStack.pop();

    Stack<string> stringStack;
    stringStack.push("Hello");
    stringStack.push("World");
    cout << stringStack.top() << endl; // 输出 World
    stringStack.pop();

    return 0;
}
```
**关键点：**
*   使用类模板时，**必须显式指定类型**（如 `Stack<int>`）。
*   在类外部定义成员函数时，每一个函数都需要加上模板声明，并且类名要带上模板参数 `<T>`。
    ```cpp
    template <typename T>
    void Stack<T>::push(const T &value) {
        elements.push_back(value);
    }
    ```

---

### 模板特化（Template Specialization）

有时，对于某些特定的类型，通用模板的实现可能不是最优的甚至是不正确的。这时可以为这些特定类型提供特殊的实现，这就是特化。

**示例：为 `const char*` 特化一个比较函数模板**
```cpp
// 通用模板
template <typename T>
bool isEqual(T a, T b) {
    return a == b;
}

// 特化版本：用于比较 C风格字符串（const char*）
template <>
bool isEqual<const char*>(const char* a, const char* b) {
    return strcmp(a, b) == 0;
}

int main() {
    // 使用通用模板，比较指针地址
    cout << isEqual("Hello", "Hello") << endl; // 可能输出 0（false），因为比较的是地址

    // 使用特化版本，比较字符串内容
    cout << isEqual<const char*>("Hello", "Hello") << endl; // 输出 1（true）
    return 0;
}
```

---

### 非类型模板参数（Non-type Template Parameters）

模板参数不仅可以类型，也可以是整型、枚举、指针或引用等值。

**示例：一个固定大小的数组类**
```cpp
template <typename T, int Size>
class FixedArray {
private:
    T data[Size]; // 大小在编译期就确定了
public:
    int getSize() const { return Size; }
    T& operator[](int index) { return data[index]; }
};

int main() {
    FixedArray<int, 5> intArray; // 创建一个大小为5的int数组
    FixedArray<double, 10> doubleArray; // 创建一个大小为10的double数组

    cout << intArray.getSize() << endl; // 输出 5
    return 0;
}
```
*   `Size` 是一个非类型参数，它的值在编译期就必须是已知的常量。

---

### 总结与注意事项

| 特性         | 函数模板                              | 类模板                               |
| :----------- | :------------------------------------ | :----------------------------------- |
| **目的**     | 生成通用函数                          | 生成通用类                           |
| **类型推导** | 支持（通常无需显式指定）              | **不支持**（必须显式指定）           |
| **语法**     | `template<typename T> void func(T a)` | `template<typename T> class MyClass` |

**注意事项：**
1.  **编译期机制**：模板是在编译期实例化的。编译器看到你使用模板时，会根据你提供的类型生成具体的代码。如果模板代码有错误（比如对某个类型不支持某种操作），在编译时会报错。
2.  **头文件**：模板的定义通常直接放在头文件（`.h` 或 `.hpp`）中。因为编译器需要看到完整的定义才能为不同的类型实例化代码。将声明和实现分离到 `.h` 和 `.cpp` 文件会导致链接错误。
3.  **代码膨胀**：模板可能会导致生成的可执行文件变大（为每种类型都生成一份代码），但现代编译器和链接器有很好的优化来消除冗余。

模板是 C++ 最强大也是最复杂的特性之一，它是理解现代 C++ 库（如 STL, Boost）的基石。