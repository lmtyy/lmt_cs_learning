好的，我们来详细介绍一下 C++ 中的函数模板。

### 1. 什么是函数模板？

函数模板是 C++ 中泛型编程的基础。它不是一个具体的函数，而是一个“蓝图”或“公式”，编译器会根据这个蓝图，在编译期自动为不同的数据类型生成具体版本的函数代码。

**核心思想：** 将数据类型参数化，编写一次代码，即可适用于多种数据类型（只要该类型支持模板中的操作）。

### 2. 为什么需要函数模板？

在没有模板之前，如果你想写一个比较两个数大小的函数，并且要支持 `int`, `double`, `float` 等类型，你必须为每一种类型都重写一个函数：

```cpp
int max(int a, int b) {
    return (a > b) ? a : b;
}

double max(double a, double b) {
    return (a > b) ? a : b;
}

float max(float a, float b) {
    return (a > b) ? a : b;
}
// ... 其他类型
```

这种方式有很多缺点：
*   **代码冗余：** 逻辑完全一样，只是类型不同，需要重复编写。
*   **不易维护：** 如果需要修改逻辑，必须修改所有重载的函数，容易出错。
*   **不支持新类型：** 如果有一个新的自定义类型（如 `Complex` 类）想使用 `max` 函数，你必须为它再重载一个版本。

**函数模板完美地解决了这些问题。** 你只需要写一个模板：

```cpp
template <typename T>
T myMax(T a, T b) {
    return (a > b) ? a : b;
}
```
编译器会自动为你需要的类型生成对应的代码。

### 3. 函数模板的语法

函数模板以关键字 `template` 开始，后面跟着一个**模板参数列表**，用尖括号 `<>` 括起来。

```cpp
template <typename T> // 或者 template <class T>
返回类型 函数名(参数列表) {
    // 函数体
}
```

*   `template`: 声明创建模板的关键字。
*   `<typename T>`: **模板参数列表**。`T` 是一个占位符，代表一种数据类型（称为**类型参数**）。在编译器编译时，会用实际的类型（如 `int`, `double`, `string` 等）替换掉 `T`。
    *   `typename` 也可以用 `class` 关键字替代，两者在此时含义完全相同。但 `typename` 更直观，是现代 C++ 的推荐用法。

#### 示例：一个简单的交换函数模板

```cpp
#include <iostream>
using namespace std;

// 函数模板声明
template <typename T>
void mySwap(T &a, T &b) {
    T temp = a;
    a = b;
    b = temp;
}

int main() {
    int i = 10, j = 20;
    cout << "Before swap: i = " << i << ", j = " << j << endl;
    mySwap(i, j); // 编译器生成 mySwap<int>(int&, int&)
    cout << "After swap: i = " << i << ", j = " << j << endl;

    double x = 1.23, y = 4.56;
    cout << "Before swap: x = " << x << ", y = " << y << endl;
    mySwap(x, y); // 编译器生成 mySwap<double>(double&, double&)
    cout << "After swap: x = " << x << ", y = " << y << endl;

    return 0;
}
```

### 4. 模板的实例化

当编译器遇到一个函数模板调用时（如 `mySwap(i, j)`），它不会立即生成代码。它会进行**模板实参推导**，根据传入的实参类型来推导模板参数 `T` 的具体类型。

推导出 `T` 的具体类型后，编译器会生成一个特定版本的函数，这个过程叫做**模板实例化**。上面例子中：
*   `mySwap(i, j)` 导致生成 `mySwap<int>(int&, int&)`
*   `mySwap(x, y)` 导致生成 `mySwap<double>(double&, double&)`

这些生成出来的函数就是**模板函数**（是具体的函数）。

你也可以**显式指定**模板参数，这在某些情况下是必要的：
```cpp
mySwap<double>(x, y); // 显式告诉编译器 T 是 double
```

### 5. 多类型模板参数

模板可以包含多个参数。

```cpp
template <typename T, typename U>
void printPair(const T& first, const U& second) {
    cout << first << ", " << second << endl;
}

int main() {
    printPair(1, 3.14); // T 是 int, U 是 double
    printPair("Hello", 100); // T 是 const char*, U 是 int
    return 0;
}
```

### 6. 函数模板的重载

函数模板也可以被重载。你可以定义同名但模板参数列表或函数参数列表不同的模板。

```cpp
// 模板重载1：一个模板参数
template <typename T>
void print(const T& value) {
    cout << "Value: " << value << endl;
}

// 模板重载2：两个模板参数
template <typename T, typename U>
void print(const T& first, const U& second) {
    cout << "Pair: " << first << ", " << second << endl;
}

// 普通函数重载：也可以和模板共存
void print(int value) {
    cout << "Special integer handling: " << value << endl;
}

int main() {
    print(10); // 调用普通函数 void print(int)，匹配度更高
    print(3.14); // 调用模板函数 void print<double>(const double&)
    print("Hello", 42); // 调用模板函数 void print<const char*, int>(...)
}
```

**重载解析规则：** 编译器会优先选择更特化、更匹配的版本。普通函数通常比模板函数更特化。

### 7. 注意事项和高级特性

1.  **类型约束：**
    模板中的操作必须对所使用的类型有效。例如，如果你的模板函数中使用 `>` 运算符，那么你用来实例化模板的类型必须支持 `>` 运算符。
    ```cpp
    class MyClass { /* 没有重载 > 运算符 */ };
    MyClass a, b;
    myMax(a, b); // 错误！MyClass 不支持 > 操作
    ```
    （C++20 引入了 Concepts 来正式解决这个问题，可以在编译期对模板参数施加约束）。

2.  **非类型模板参数：**
    模板参数不仅可以类型，也可以是整型、指针或引用等值。
    ```cpp
    template <typename T, int size>
    void printArray(T (&arr)[size]) { // 接收数组的引用，并推导出其大小
        for (int i = 0; i < size; ++i) {
            cout << arr[i] << " ";
        }
        cout << endl;
    }
    
    int main() {
        int arr[] = {1, 2, 3, 4, 5};
        printArray(arr); // 编译器推导出 T 是 int, size 是 5
    }
    ```

### 总结

| 特性       | 描述                                                         |
| :--------- | :----------------------------------------------------------- |
| **目的**   | 实现泛型编程，提高代码复用性。                               |
| **关键字** | `template`, `typename` (或 `class`)                          |
| **核心**   | 将数据类型参数化。                                           |
| **过程**   | 编译期由编译器进行实参推导和实例化，生成具体的模板函数。     |
| **优点**   | 代码复用，类型安全，性能与手写代码几乎无异（零开销抽象）。   |
| **注意**   | 模板代码通常直接放在头文件(.h或.hpp)中，因为编译需要看到其完整定义。 |

函数模板是 C++ 强大功能的基石，STL（标准模板库）就是构建在模板技术之上的。