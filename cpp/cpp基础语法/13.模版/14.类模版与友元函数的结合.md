好的，这个问题涉及 **类模板 + 友元函数** 的 **类内 / 类外实现**，我们分情况讲清楚。

------

## 1. 背景知识

- 在 **类模板** 中，可以定义 **友元函数**。
- 友元函数的声明可以放在类内，但具体实现可以在类内（类内定义 = inline）、也可以在类外。
- 类外实现时，写法容易出错，主要是因为需要同时处理模板参数的作用域问题。

------

## 2. 基本示例（类内定义友元函数）

```cpp
#include <iostream>
using namespace std;

template <typename T>
class Box {
private:
    T value;
public:
    Box(T v): value(v) {}

    // 友元函数声明 + 定义（类内）
    friend void print(const Box<T>& b) {
        cout << "Box: " << b.value << endl;
    }
};

int main() {
    Box<int> b1(42);
    Box<string> b2("hello");
    print(b1);
    print(b2);
}
```

👉 这种方式最简单，类内定义的友元函数 **直接成为内联函数**，不需要额外模板参数说明。

------

## 3. 类内声明，类外实现（常见写法）

要点：

1. 在类内 **只写声明**；
2. 在类外实现时，必须再写一遍 `template <typename T>`；
3. 注意函数属于类模板的“朋友”，但不在类作用域里，所以写法稍有区别。

```cpp
#include <iostream>
using namespace std;

template <typename T>
class Box {
private:
    T value;
public:
    Box(T v): value(v) {}

    // 只声明为友元
    friend void print(const Box<T>& b);
};

// 类外实现
template <typename T>
void print(const Box<T>& b) {
    cout << "Box: " << b.value << endl;
}

int main() {
    Box<int> b1(123);
    Box<string> b2("world");
    print(b1);
    print(b2);
}
```

👉 注意这里 `friend void print(const Box<T>& b);` **不是成员函数声明**，它只是一个 **友元函数声明**，在类外实现时要重新写模板头。

------

## 4. 如果希望一个函数成为所有模板实例的友元

有时希望 **不同类型的 Box 共享同一个友元函数**，这就需要写成函数模板友元。

```cpp
#include <iostream>
using namespace std;

template <typename T>
class Box {
private:
    T value;
public:
    Box(T v): value(v) {}

    // 友元是一个函数模板（注意模板参数独立于类的模板参数）
    template <typename U>
    friend void print(const Box<U>& b);
};

// 类外实现
template <typename U>
void print(const Box<U>& b) {
    cout << "Box: " << b.value << endl;
}

int main() {
    Box<int> b1(11);
    Box<double> b2(3.14);
    Box<string> b3("template");

    print(b1);  // OK
    print(b2);  // OK
    print(b3);  // OK
}
```

👉 这里 `print` 是一个 **函数模板**，所有 `Box<T>` 都可以用它，而不是每个 `Box<T>` 都生成一个独立的 `print`。

------

## 5. 总结

- **类内定义友元函数**：简单直接，自动内联。
- **类内声明 + 类外实现**：常见写法，要重新写模板头。
- **所有实例共享的友元函数**：需要用函数模板形式。

