问得非常好！答案是：**不一定，取决于类模板是否有默认模板参数**。

分为两种情况：

---

### 情况一：没有提供默认模板参数 → **会报错**

如果类模板声明时没有为它的参数提供默认值，那么你在使用时**必须**提供模板实参，否则编译器无法知道 `T` 应该是什么具体类型，会导致编译错误。

```cpp
// 这个类模板没有默认参数
template <typename T>
class Box {
    T content;
public:
    Box(T value) : content(value) {}
    T get() { return content; }
};

int main() {
    Box obj1(10);     // 错误！缺少模板实参列表 <>
    Box<> obj2(10);   // 错误！T 没有默认类型，无法推导
    Box<int> obj3(10); // 正确！显式提供了模板实参 int

    return 0;
}
```

**编译器错误信息通常会类似于：**
- `use of class template requires template arguments`
- `invalid use of template-name 'Box' without an argument list`

---

### 情况二：提供了默认模板参数 → **不会报错**

如果类模板在声明时为其参数提供了默认值，那么你在使用时就可以**省略**模板实参，编译器会自动使用默认参数。

```cpp
// 这个类模板为类型参数 T 提供了默认类型 int
template <typename T = int> // 注意这里的 = int
class Box {
    T content;
public:
    Box(T value) : content(value) {}
    T get() { return content; }
};

int main() {
    Box<int> obj1(10);   // 正确！显式指定 T 为 int
    Box<> obj2(10);      // 正确！使用默认参数 T = int
    Box obj3(10);        // 正确！在 C++17 及以上标准中，可以完全省略 <>

    return 0;
}
```

#### 关于 `Box obj3(10);` 的特别说明：

这种完全省略 `<>` 的语法被称为 **类模板实参推导（CTAD, Class Template Argument Deduction）**，是 **C++17** 引入的特性。

- **C++17 之前**：必须至少写 `Box<>` 来表明这是一个模板
- **C++17 及之后**：如果构造函数能推导出所有模板参数的类型，可以完全省略 `<>`

---

### 总结对比表

| 场景                    | 代码示例            | 是否报错 | 说明                                        |
| :---------------------- | :------------------ | :------- | :------------------------------------------ |
| **无默认参数**          | `Box obj(10);`      | **是**   | 编译器不知道 `T` 是什么                     |
| **无默认参数**          | `Box<> obj(10);`    | **是**   | `<>` 是空的，没有提供 `T` 的类型            |
| **有默认参数**          | `Box<> obj(10);`    | **否**   | 使用默认参数 `T = int`                      |
| **有默认参数** (C++17+) | `Box obj(10);`      | **否**   | CTAD 根据构造函数参数 `10` 推导出 `T = int` |
| **任何情况**            | `Box<int> obj(10);` | **否**   | 显式指定类型，最安全可靠                    |

**最佳实践：**
为了代码的清晰性和可移植性（尤其是需要考虑旧标准时），**建议总是显式地写出模板实参**，即使有默认参数。例如，使用 `Box<int>` 而不是依赖 `Box<>` 或 CTAD。