---

## 1. 字符串类型体系

C++中的字符串主要分为两大类：

### 1.1 C风格字符串
- **字符数组**：以空字符`\0`结尾的`char`数组
- **指针表示**：`char*`或`const char*`指向字符串

### 1.2 C++字符串类
- **`std::string`**：基于`char`的标准字符串（最常用）
- **`std::wstring`**：基于`wchar_t`的宽字符串
- **`std::u16string`**：基于`char16_t`的UTF-16字符串（C++11）
- **`std::u32string`**：基于`char32_t`的UTF-32字符串（C++11）
- **`std::string_view`**：字符串视图，不拥有数据（C++17）

---

## 2. C风格字符串

### 2.1 基本定义和使用
```cpp
#include <iostream>
#include <cstring>  // C字符串函数
using namespace std;

int main() {
    // 方式1：字符数组（自动添加\0）
    char str1[] = "Hello";
    
    // 方式2：显式指定大小
    char str2[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
    
    // 方式3：字符指针
    const char* str3 = "Hello";
    
    cout << "str1: " << str1 << endl;
    cout << "str2: " << str2 << endl;
    cout << "str3: " << str3 << endl;
    
    return 0;
}
```

### 2.2 常用C字符串函数
```cpp
#include <iostream>
#include <cstring>
using namespace std;

void c_string_functions() {
    char str1[20] = "Hello";
    char str2[20] = "World";
    char str3[20];
    
    // 字符串长度（不包括\0）
    cout << "str1长度: " << strlen(str1) << endl;
    
    // 字符串复制
    strcpy(str3, str1);
    cout << "复制后str3: " << str3 << endl;
    
    // 字符串连接
    strcat(str3, " ");
    strcat(str3, str2);
    cout << "连接后str3: " << str3 << endl;
    
    // 字符串比较
    int cmp = strcmp(str1, str2);
    cout << "比较结果: " << cmp << endl;
    // <0: str1 < str2, =0: 相等, >0: str1 > str2
    
    // 字符串查找
    char* found = strstr(str3, "World");
    if (found) {
        cout << "找到子串位置: " << found - str3 << endl;
    }
    
    // 字符查找
    char* char_found = strchr(str1, 'e');
    if (char_found) {
        cout << "找到字符位置: " << char_found - str1 << endl;
    }
}
```

---

## 3. std::string（最常用的字符串类）

### 3.1 基本操作
```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    // 多种构造方式
    string s1;                   // 空字符串
    string s2 = "Hello";         // 从C字符串构造
    string s3("World");          // 直接构造
    string s4(5, 'A');           // 5个'A'
    string s5(s2);               // 拷贝构造
    string s6(s2, 1, 3);         // 从位置1开始，取3个字符："ell"
    
    cout << "s1: '" << s1 << "'" << endl;
    cout << "s2: " << s2 << endl;
    cout << "s3: " << s3 << endl;
    cout << "s4: " << s4 << endl;
    cout << "s5: " << s5 << endl;
    cout << "s6: " << s6 << endl;
    
    return 0;
}
```

### 3.2 字符串操作和修改
```cpp
#include <iostream>
#include <string>
using namespace std;

void string_operations() {
    string str = "Hello";
    
    // 获取长度
    cout << "长度: " << str.length() << endl;     // 5
    cout << "大小: " << str.size() << endl;       // 5
    cout << "是否为空: " << str.empty() << endl;   // 0
    
    // 访问字符
    cout << "第一个字符: " << str[0] << endl;      // H
    cout << "最后一个字符: " << str.back() << endl; // o
    cout << "第二个字符: " << str.at(1) << endl;   // e
    
    // 修改字符串
    str.append(" World");          // Hello World
    str += "!";                    // Hello World!
    str.insert(5, " C++");         // Hello C++ World!
    str.replace(6, 3, "Programming"); // Hello Programming World!
    str.erase(5, 12);              // Hello!
    
    cout << "修改后: " << str << endl;
    
    // 清空字符串
    str.clear();
    cout << "清空后是否为空: " << str.empty() << endl;
}
```

### 3.3 字符串查找和比较
```cpp
#include <iostream>
#include <string>
using namespace std;

void string_search_compare() {
    string text = "The quick brown fox jumps over the lazy dog";
    string word = "fox";
    
    // 查找
    size_t pos = text.find(word);
    if (pos != string::npos) {
        cout << "找到 '" << word << "' 在位置: " << pos << endl;
    }
    
    // 从后往前查找
    pos = text.rfind("the");
    if (pos != string::npos) {
        cout << "从后找到 'the' 在位置: " << pos << endl;
    }
    
    // 查找任意字符
    pos = text.find_first_of("aeiou");
    cout << "第一个元音在位置: " << pos << endl;
    
    pos = text.find_last_not_of(" \t\n");
    cout << "最后一个非空白字符在位置: " << pos << endl;
    
    // 字符串比较
    string s1 = "apple";
    string s2 = "banana";
    
    int result = s1.compare(s2);
    if (result < 0) {
        cout << s1 << " < " << s2 << endl;
    } else if (result > 0) {
        cout << s1 << " > " << s2 << endl;
    } else {
        cout << s1 << " == " << s2 << endl;
    }
}
```

---

## 4. 字符串转换

### 4.1 数值转换
```cpp
#include <iostream>
#include <string>
#include <sstream>
using namespace std;

void number_conversion() {
    // 数字转字符串
    int num = 42;
    double pi = 3.14159;
    
    string str_num = to_string(num);
    string str_pi = to_string(pi);
    
    cout << "整数转字符串: " << str_num << endl;
    cout << "浮点数转字符串: " << str_pi << endl;
    
    // 字符串转数字
    string str_int = "123";
    string str_double = "3.14";
    
    int converted_int = stoi(str_int);
    double converted_double = stod(str_double);
    
    cout << "字符串转整数: " << converted_int << endl;
    cout << "字符串转浮点数: " << converted_double << endl;
    
    // 使用stringstream进行复杂转换
    stringstream ss;
    ss << "年龄: " << 25 << ", 分数: " << 95.5;
    string complex_str = ss.str();
    cout << "复杂转换: " << complex_str << endl;
}
```

### 4.2 大小写转换
```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <cctype>
using namespace std;

void case_conversion() {
    string text = "Hello World 123";
    
    // 转换为大写
    string upper = text;
    transform(upper.begin(), upper.end(), upper.begin(), ::toupper);
    cout << "大写: " << upper << endl;
    
    // 转换为小写
    string lower = text;
    transform(lower.begin(), lower.end(), lower.begin(), ::tolower);
    cout << "小写: " << lower << endl;
    
    // 手动转换
    for (char& c : text) {
        if (islower(c)) c = toupper(c);
        else if (isupper(c)) c = tolower(c);
    }
    cout << "大小写互换: " << text << endl;
}
```

---

## 5. 字符串分割和连接

### 5.1 字符串分割
```cpp
#include <iostream>
#include <string>
#include <vector>
#include <sstream>
using namespace std;

vector<string> split_string(const string& str, char delimiter) {
    vector<string> tokens;
    stringstream ss(str);
    string token;
    
    while (getline(ss, token, delimiter)) {
        if (!token.empty()) {
            tokens.push_back(token);
        }
    }
    
    return tokens;
}

void string_splitting() {
    string text = "apple,banana,cherry,date";
    string csv = "John,Doe,25,New York";
    
    // 按逗号分割
    vector<string> fruits = split_string(text, ',');
    cout << "水果列表:" << endl;
    for (const auto& fruit : fruits) {
        cout << "- " << fruit << endl;
    }
    
    // 按空格分割
    string sentence = "The quick brown fox";
    vector<string> words = split_string(sentence, ' ');
    cout << "单词列表:" << endl;
    for (const auto& word : words) {
        cout << "- " << word << endl;
    }
}
```

### 5.2 字符串连接
```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

void string_joining() {
    vector<string> words = {"Hello", "world", "from", "C++"};
    
    // 方法1：使用+运算符
    string result1;
    for (const auto& word : words) {
        result1 += word + " ";
    }
    cout << "方法1: " << result1 << endl;
    
    // 方法2：使用append
    string result2;
    for (const auto& word : words) {
        result2.append(word).append(" ");
    }
    cout << "方法2: " << result2 << endl;
    
    // 方法3：使用stringstream
    stringstream ss;
    for (const auto& word : words) {
        ss << word << " ";
    }
    string result3 = ss.str();
    cout << "方法3: " << result3 << endl;
}
```

---

## 6. 现代C++字符串特性

### 6.1 std::string_view（C++17）
```cpp
#include <iostream>
#include <string>
#include <string_view>
using namespace std;

void string_view_demo() {
    string long_text = "This is a very long string that we don't want to copy";
    
    // 创建string_view，不复制数据
    string_view view(long_text);
    
    // 可以像string一样使用
    cout << "长度: " << view.length() << endl;
    cout << "子串: " << view.substr(10, 15) << endl;
    
    // 查找操作
    size_t pos = view.find("long");
    if (pos != string_view::npos) {
        cout << "找到 'long' 在位置: " << pos << endl;
    }
    
    // string_view不管理内存，原始字符串必须保持有效
}
```

### 6.2 原始字符串字面量（C++11）
```cpp
#include <iostream>
#include <string>
using namespace std;

void raw_string_literals() {
    // 传统字符串（需要转义）
    string path1 = "C:\\Program Files\\MyApp\\config.txt";
    string regex1 = "\\d+\\.\\d+";
    
    // 原始字符串（不需要转义）
    string path2 = R"(C:\Program Files\MyApp\config.txt)";
    string regex2 = R"(\d+\.\d+)";
    
    // 多行原始字符串
    string multi_line = R"(
        #include <iostream>
        using namespace std;
        
        int main() {
            cout << "Hello World" << endl;
            return 0;
        }
    )";
    
    cout << "路径1: " << path1 << endl;
    cout << "路径2: " << path2 << endl;
    cout << "多行文本:\n" << multi_line << endl;
}
```

---

## 7. 字符串性能优化

### 7.1 避免不必要的复制
```cpp
#include <iostream>
#include <string>
using namespace std;

void process_string(const string& str) {  // 传const引用，避免复制
    cout << "处理字符串: " << str << endl;
}

void modify_string(string& str) {         // 传引用，可以修改
    str += " (modified)";
}

void string_performance() {
    string large_string(1000, 'A');  // 创建大字符串
    
    // 不好：会复制整个字符串
    // void bad_function(string str);
    
    // 好：传递引用，避免复制
    process_string(large_string);
    
    // 如果需要修改，也传递引用
    modify_string(large_string);
    cout << "修改后: " << large_string << endl;
    
    // 使用移动语义（C++11）
    string moved_string = move(large_string);
    cout << "移动后原字符串: '" << large_string << "'" << endl;  // 可能为空
    cout << "移动后新字符串: " << moved_string << endl;
}
```

### 7.2 预留空间优化
```cpp
#include <iostream>
#include <string>
#include <chrono>
using namespace std;
using namespace chrono;

void reserve_optimization() {
    // 不预留空间
    auto start1 = high_resolution_clock::now();
    string str1;
    for (int i = 0; i < 100000; i++) {
        str1 += "a";  // 可能导致多次重新分配
    }
    auto end1 = high_resolution_clock::now();
    
    // 预留空间
    auto start2 = high_resolution_clock::now();
    string str2;
    str2.reserve(100000);  // 预先分配足够空间
    for (int i = 0; i < 100000; i++) {
        str2 += "a";  // 不会重新分配
    }
    auto end2 = high_resolution_clock::now();
    
    auto duration1 = duration_cast<microseconds>(end1 - start1);
    auto duration2 = duration_cast<microseconds>(end2 - start2);
    
    cout << "不预留时间: " << duration1.count() << " μs" << endl;
    cout << "预留时间: " << duration2.count() << " μs" << endl;
    cout << "性能提升: " << (duration1.count() - duration2.count()) << " μs" << endl;
}
```

---

## 8. 实际应用示例

### 8.1 配置文件解析
```cpp
#include <iostream>
#include <string>
#include <map>
#include <sstream>
#include <fstream>
using namespace std;

map<string, string> parse_config(const string& filename) {
    map<string, string> config;
    ifstream file(filename);
    
    if (!file.is_open()) {
        throw runtime_error("无法打开配置文件");
    }
    
    string line;
    while (getline(file, line)) {
        // 跳过空行和注释
        if (line.empty() || line[0] == '#') continue;
        
        size_t pos = line.find('=');
        if (pos != string::npos) {
            string key = line.substr(0, pos);
            string value = line.substr(pos + 1);
            
            // 去除前后空白
            key.erase(0, key.find_first_not_of(" \t"));
            key.erase(key.find_last_not_of(" \t") + 1);
            
            value.erase(0, value.find_first_not_of(" \t"));
            value.erase(value.find_last_not_of(" \t") + 1);
            
            config[key] = value;
        }
    }
    
    return config;
}
```

### 8.2 字符串加密解密
```cpp
#include <iostream>
#include <string>
using namespace std;

string caesar_cipher(const string& text, int shift) {
    string result;
    
    for (char c : text) {
        if (isalpha(c)) {
            char base = islower(c) ? 'a' : 'A';
            c = (c - base + shift) % 26;
            if (c < 0) c += 26;
            result += base + c;
        } else {
            result += c;
        }
    }
    
    return result;
}

void encryption_demo() {
    string original = "Hello, World! 123";
    int shift = 3;
    
    string encrypted = caesar_cipher(original, shift);
    string decrypted = caesar_cipher(encrypted, -shift);
    
    cout << "原文: " << original << endl;
    cout << "加密: " << encrypted << endl;
    cout << "解密: " << decrypted << endl;
}
```

---

## 9. 最佳实践总结

### 9.1 字符串处理最佳实践
```cpp
#include <iostream>
#include <string>
#include <string_view>
using namespace std;

void best_practices() {
    // 1. 优先使用std::string而不是C风格字符串
    string modern_str = "Modern C++";
    
    // 2. 对于只读访问，使用string_view（C++17）
    string_view view = modern_str;
    
    // 3. 避免不必要的字符串复制
    void process_string(const string& str);  // 使用const引用
    
    // 4. 预先分配空间避免重复分配
    string large_str;
    large_str.reserve(1000);
    
    // 5. 使用现代转换函数
    int num = stoi("42");
    string str_num = to_string(42);
    
    // 6. 正确处理Unicode（如果需要）
    u16string utf16_str = u"你好世界";
    u32string utf32_str = U"😊";
    
    // 7. 使用原始字符串字面量处理复杂文本
    string regex = R"(\d+\.\d+)";
    string path = R"(C:\Program Files\MyApp)";
}
```

### 9.2 内存安全实践
```cpp
#include <iostream>
#include <string>
#include <memory>
using namespace std;

void memory_safety() {
    // 使用智能指针管理C风格字符串（如果需要）
    unique_ptr<char[]> c_str(new char[100]);
    strcpy(c_str.get(), "Safe C string");
    
    // 或者直接使用std::string
    string safe_str = "更安全的字符串";
    
    // 避免缓冲区溢出
    char buffer[10];
    string input;
    getline(cin, input);
    
    // 安全复制
    if (input.size() < sizeof(buffer)) {
        strcpy(buffer, input.c_str());
    } else {
        cerr << "输入过长！" << endl;
    }
    
    // 或者直接使用std::string，避免这些问题
}
```

---

## 总结

C++字符串处理的关键要点：

1. **多种选择**：C风格字符串、`std::string`、各种Unicode字符串
2. **丰富功能**：查找、替换、分割、连接、转换等
3. **性能考虑**：预留空间、避免复制、使用`string_view`
4. **现代特性**：原始字符串、移动语义、字符串视图
5. **安全第一**：避免缓冲区溢出，使用现代字符串类

