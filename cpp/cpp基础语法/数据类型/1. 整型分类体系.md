整型是C++中最基础、最常用的数据类型，用于表示整数。

---

## 1. 整型分类体系

C++整型可以按以下维度分类：

### 按符号性 (Signedness)
- **有符号整型 (signed)**：可以表示正数、负数和零。
- **无符号整型 (unsigned)**：只能表示非负数（零和正数）。

### 按大小/精度 (Size/Precision)
从最小到最大：
1. **字符型** (`char`, `signed char`, `unsigned char`) - 通常1字节
2. **短整型** (`short`, `unsigned short`) - 至少2字节
3. **整型** (`int`, `unsigned int`) - 通常4字节
4. **长整型** (`long`, `unsigned long`) - 至少4字节
5. **长长整型** (`long long`, `unsigned long long`) - 至少8字节

---

## 2. 具体整型类型详解

### 基本整型类型表

| 类型                 | 别名                     | 典型大小 | 取值范围（典型）                                        | 说明               |
| -------------------- | ------------------------ | -------- | ------------------------------------------------------- | ------------------ |
| `signed char`        | -                        | 1字节    | -128 到 127                                             | 有符号字符型       |
| `unsigned char`      | -                        | 1字节    | 0 到 255                                                | 无符号字符型       |
| `char`               | -                        | 1字节    | -128 到 127 或 0 到 255                                 | 实现定义的有无符号 |
| `short`              | `short int`              | 2字节    | -32,768 到 32,767                                       | 短整型             |
| `unsigned short`     | `unsigned short int`     | 2字节    | 0 到 65,535                                             | 无符号短整型       |
| `int`                | `signed int`             | 4字节    | -2,147,483,648 到 2,147,483,647                         | 最常用的整型       |
| `unsigned int`       | -                        | 4字节    | 0 到 4,294,967,295                                      | 无符号整型         |
| `long`               | `long int`               | 4或8字节 | -2³¹ 到 2³¹-1 或 -2⁶³ 到 2⁶³-1                          | 长整型             |
| `unsigned long`      | `unsigned long int`      | 4或8字节 | 0 到 2³²-1 或 0 到 2⁶⁴-1                                | 无符号长整型       |
| `long long`          | `long long int`          | 8字节    | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 | 长长整型(C++11)    |
| `unsigned long long` | `unsigned long long int` | 8字节    | 0 到 18,446,744,073,709,551,615                         | 无符号长长整型     |

---

## 3. 如何确定具体大小？

由于C++标准只规定**最小尺寸**，实际大小取决于编译器和平台。可以使用`sizeof`运算符查询：

```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "Size of char: " << sizeof(char) << " byte" << endl;
    cout << "Size of short: " << sizeof(short) << " bytes" << endl;
    cout << "Size of int: " << sizeof(int) << " bytes" << endl;
    cout << "Size of long: " << sizeof(long) << " bytes" << endl;
    cout << "Size of long long: " << sizeof(long long) << " bytes" << endl;
    
    // 也可以查看取值范围
    cout << "int range: [" << INT_MIN << " to " << INT_MAX << "]" << endl;
    cout << "unsigned int max: " << UINT_MAX << endl;
    
    return 0;
}
```

**典型输出（64位Windows/Linux）**：
```
Size of char: 1 byte
Size of short: 2 bytes
Size of int: 4 bytes
Size of long: 4 bytes  // Windows通常为4，Linux通常为8
Size of long long: 8 bytes
```

---

## 4. 整型字面量 (Integer Literals)

### 不同进制的表示
```cpp
int decimal = 42;       // 十进制
int octal = 052;        // 八进制（以0开头）
int hexadecimal = 0x2A; // 十六进制（以0x开头）
int binary = 0b101010;  // 二进制（C++14起，以0b开头）
```

### 类型后缀
```cpp
auto a = 42;        // int
auto b = 42U;       // unsigned int
auto c = 42L;       // long
auto d = 42UL;      // unsigned long
auto e = 42LL;      // long long
auto f = 42ULL;     // unsigned long long
```

---

## 5. 有符号与无符号的注意事项

### 混用时的隐式转换
```cpp
unsigned int u = 10;
int i = -5;

cout << u + i << endl; // 输出4294967301（在32位系统中）
// 因为i被转换为unsigned int，产生巨大的正数
```

### 循环中的陷阱
```cpp
// 危险：无限循环！
for (unsigned int i = 10; i >= 0; --i) {
    cout << i << endl;
    // 当i为0时，--i会变成UINT_MAX（非常大的数）
}
```

---

## 6. 固定宽度整型 (C++11)

为了解决可移植性问题，C++11在`<cstdint>`头文件中引入了固定宽度整型：

| 类型                            | 含义                  | 说明                                   |
| ------------------------------- | --------------------- | -------------------------------------- |
| `int8_t`, `uint8_t`             | 精确8位整型           | 通常就是`signed char`和`unsigned char` |
| `int16_t`, `uint16_t`           | 精确16位整型          |                                        |
| `int32_t`, `uint32_t`           | 精确32位整型          |                                        |
| `int64_t`, `uint64_t`           | 精确64位整型          |                                        |
| `int_least8_t`, `uint_least8_t` | 至少8位整型           |                                        |
| `int_fast8_t`, `uint_fast8_t`   | 最快操作的至少8位整型 |                                        |

**示例**：
```cpp
#include <cstdint>

int32_t precise32Bit = 100;    // 保证是32位
uint64_t largeUnsigned = 1000; // 保证是64位无符号
```

---

## 7. 最佳实践和建议

1. **默认选择 `int`**：对于一般整数计算，`int`是最自然和高效的选择。

2. **明确无符号需求**：只有在需要位运算或确保非负时才使用`unsigned`。

3. **考虑可移植性时用固定宽度整型**：
   ```cpp
   #include <cstdint>
   
   int32_t score = 100;  // 明确32位
   uint16_t port = 8080; // 明确16位无符号
   ```

4. **避免类型混用**：特别注意有符号和无符号的混合运算。

5. **使用类型别名增强可读性**：
   ```cpp
   using UserId = uint32_t;
   using Byte = uint8_t;
   
   UserId id = 12345;
   Byte data = 0xFF;
   ```

6. **处理大数时用 `long long`**：当`int`范围不够时（超过±20亿）。

---

## 8. 范围溢出处理

```cpp
#include <iostream>
#include <limits>
using namespace std;

int main() {
    int max_int = numeric_limits<int>::max();
    cout << "Max int: " << max_int << endl;
    
    max_int += 1; // 有符号溢出是未定义行为(UB)
    cout << "After overflow: " << max_int << endl; // 结果不可预测
    
    unsigned int max_uint = numeric_limits<unsigned int>::max();
    cout << "Max uint: " << max_uint << endl;
    
    max_uint += 1; // 无符号溢出是定义良好的（回绕）
    cout << "After overflow: " << max_uint << endl; // 输出0
    
    return 0;
}
```

---

## 总结

C++提供了丰富的整型类型来满足不同需求。选择时应考虑：
- **所需范围**：选择能容纳所有可能值的足够大的类型
- **内存效率**：在满足需求的前提下选择较小的类型
- **符号需求**：是否需要负数
- **可移植性**：是否需要固定大小的整型

