浮点数是C++中用于表示实数（带小数点的数）的数据类型，遵循IEEE 754标准。

---

## 1. 浮点数类型体系

C++主要提供三种浮点数类型，按精度从低到高排列：

| 类型          | 典型大小      | 精度              | 取值范围（近似）          | 说明                 |
| ------------- | ------------- | ----------------- | ------------------------- | -------------------- |
| `float`       | 4字节（32位） | 约6-7位十进制数   | ±1.2×10⁻³⁸ 到 ±3.4×10³⁸   | 单精度浮点数         |
| `double`      | 8字节（64位） | 约15-16位十进制数 | ±2.2×10⁻³⁰⁸ 到 ±1.8×10³⁰⁸ | 双精度浮点数（默认） |
| `long double` | 10-16字节     | 约18-19位十进制数 | 范围更大                  | 扩展精度浮点数       |

---

## 2. 浮点数表示原理（IEEE 754）

以32位`float`为例，其二进制结构为：
```
[符号位 S][指数位 E][尾数位 M]
1位      8位       23位
```

**计算公式**：$(-1)^S × 1.M × 2^{E-127}$

**示例**：-13.625 的存储
1. 转换为二进制：-1101.101
2. 规范化：-1.101101 × 2³
3. 符号位 S = 1（负数）
4. 指数 E = 3 + 127 = 130（10000010）
5. 尾数 M = 10110100000000000000000

---

## 3. 浮点数字面量

```cpp
float f1 = 3.14f;      // f或F后缀表示float
double d1 = 3.14;      // 默认是double
long double ld1 = 3.14L; // L后缀表示long double

// 科学计数法
double scientific = 1.23e5;    // 1.23 × 10⁵ = 123000
double small = 1.23e-5;        // 1.23 × 10⁻⁵ = 0.0000123

// 不同进制（C++17起）
double hex_float = 0x1.2p3;    // 1.2₁₆ × 2³ = 9.0
```

---

## 4. 特殊值表示

浮点数有几个特殊值：

```cpp
#include <iostream>
#include <cmath>
#include <limits>
using namespace std;

int main() {
    // 无穷大
    double inf = numeric_limits<double>::infinity();
    double neg_inf = -numeric_limits<double>::infinity();
    cout << "Infinity: " << inf << endl;
    cout << "-Infinity: " << neg_inf << endl;
    
    // 非数字（NaN）
    double nan = numeric_limits<double>::quiet_NaN();
    cout << "NaN: " << nan << endl;
    
    // 检查特殊值
    cout << "Is infinity: " << isinf(inf) << endl;
    cout << "Is NaN: " << isnan(nan) << endl;
    
    return 0;
}
```

**输出**：
```
Infinity: inf
-Infinity: -inf
NaN: nan
Is infinity: 1
Is NaN: 1
```

---

## 5. 精度问题和比较陷阱

### 精度损失示例
```cpp
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    float f1 = 0.1f;
    float f2 = 0.2f;
    float sum = f1 + f2;
    
    cout << setprecision(20);
    cout << "0.1 + 0.2 = " << sum << endl;  // 可能不是精确的0.3
    cout << "Expected: 0.3" << endl;
    
    return 0;
}
```

**可能的输出**：
```
0.1 + 0.2 = 0.30000001192092895508
Expected: 0.3
```

### 正确的比较方法
```cpp
#include <cmath>

// 错误的方式（不要这样比较！）
if (a == b) { /* 可能永远不成立 */ }

// 正确的方式：使用容差比较
bool approximatelyEqual(double a, double b, double epsilon = 1e-6) {
    return fabs(a - b) <= epsilon;
}

bool essentiallyEqual(double a, double b, double epsilon = 1e-6) {
    return fabs(a - b) <= epsilon * max(fabs(a), fabs(b));
}

// 或者使用标准库函数
#include <cmath>
bool isEqual = std::abs(a - b) < std::numeric_limits<double>::epsilon();
```

---

## 6. 数值极限和特性查询

```cpp
#include <iostream>
#include <limits>
#include <cmath>
using namespace std;

int main() {
    // 查询浮点数特性
    cout << "float size: " << sizeof(float) << " bytes" << endl;
    cout << "double size: " << sizeof(double) << " bytes" << endl;
    cout << "long double size: " << sizeof(long double) << " bytes" << endl;
    
    // 数值极限
    cout << "float min: " << numeric_limits<float>::min() << endl;      // 最小正规范化数
    cout << "float max: " << numeric_limits<float>::max() << endl;      // 最大有限值
    cout << "float lowest: " << numeric_limits<float>::lowest() << endl; // 最小有限值
    cout << "float epsilon: " << numeric_limits<float>::epsilon() << endl; // 机器精度
    cout << "float digits10: " << numeric_limits<float>::digits10 << endl; // 十进制精度位数
    
    // 检查特性
    cout << "float is IEC559: " << numeric_limits<float>::is_iec559 << endl; // 是否符合IEEE 754
    cout << "float has infinity: " << numeric_limits<float>::has_infinity << endl;
    
    return 0;
}
```

---

## 7. 数学函数库

C++提供了丰富的数学函数：

```cpp
#include <iostream>
#include <cmath>
using namespace std;

int main() {
    double x = 2.0, y = 3.0;
    
    // 基本运算
    cout << "sqrt(" << x << ") = " << sqrt(x) << endl;
    cout << "pow(" << x << ", " << y << ") = " << pow(x, y) << endl;
    cout << "exp(" << x << ") = " << exp(x) << endl;    // eˣ
    cout << "log(" << x << ") = " << log(x) << endl;    // 自然对数
    cout << "log10(" << x << ") = " << log10(x) << endl; // 常用对数
    
    // 三角函数（参数为弧度）
    cout << "sin(π/2) = " << sin(M_PI/2) << endl;
    cout << "cos(π) = " << cos(M_PI) << endl;
    cout << "tan(π/4) = " << tan(M_PI/4) << endl;
    
    // 双曲函数
    cout << "sinh(1) = " << sinh(1.0) << endl;
    cout << "cosh(1) = " << cosh(1.0) << endl;
    
    // 取整函数
    cout << "ceil(2.3) = " << ceil(2.3) << endl;    // 向上取整 → 3
    cout << "floor(2.7) = " << floor(2.7) << endl;  // 向下取整 → 2
    cout << "round(2.5) = " << round(2.5) << endl;  // 四舍五入 → 3
    cout << "trunc(2.7) = " << trunc(2.7) << endl;  // 截断小数 → 2
    
    return 0;
}
```

---

## 8. 最佳实践和建议

### 1. 类型选择原则
```cpp
// 默认使用 double（精度和性能的平衡）
double distance = 123.456;

// 内存敏感时用 float
float temperature = 23.5f;

// 需要极高精度时用 long double
long double scientific_constant = 1.234567890123456789L;
```

### 2. 避免精度损失的技巧
```cpp
// 避免大数小数相加减
double big = 1e10;
double small = 1e-10;
double bad_sum = big + small;  // small可能被忽略

// 按数量级排序后相加
double numbers[] = {1e10, 1e9, 1e8, 1e-8, 1e-9, 1e-10};
// 先排序再相加可减少精度损失
```

### 3. 使用高精度库
当内置浮点数精度不够时：
```cpp
// 考虑使用高精度数学库，如：
// - GNU MPFR
// - Boost.Multiprecision
// - Intel Decimal Floating-Point Math Library
```

### 4. 数值稳定性
```cpp
// 避免病态数学问题
// 错误的二次公式（可能产生灾难性抵消）
double x1 = (-b + sqrt(b*b - 4*a*c)) / (2*a);
double x2 = (-b - sqrt(b*b - 4*a*c)) / (2*a);

// 更稳定的版本
if (b >= 0) {
    x1 = (-b - sqrt(b*b - 4*a*c)) / (2*a);
    x2 = (2*c) / (-b - sqrt(b*b - 4*a*c));
} else {
    x1 = (2*c) / (-b + sqrt(b*b - 4*a*c));
    x2 = (-b + sqrt(b*b - 4*a*c)) / (2*a);
}
```

---

## 9. 实际应用示例

```cpp
#include <iostream>
#include <cmath>
#include <iomanip>
using namespace std;

// 金融计算：复利计算
double compoundInterest(double principal, double rate, int years) {
    return principal * pow(1 + rate/100, years);
}

// 物理计算：抛物线运动
double projectileRange(double velocity, double angle) {
    const double g = 9.81;
    double angle_rad = angle * M_PI / 180.0;
    return (velocity * velocity * sin(2 * angle_rad)) / g;
}

int main() {
    cout << fixed << setprecision(2);
    
    // 金融计算
    double investment = 10000.0;
    double annual_rate = 5.0;
    int years = 10;
    double future_value = compoundInterest(investment, annual_rate, years);
    cout << "Future value: $" << future_value << endl;
    
    // 物理计算
    double v0 = 50.0;  // m/s
    double angle = 45.0; // degrees
    double range = projectileRange(v0, angle);
    cout << "Projectile range: " << range << " meters" << endl;
    
    return 0;
}
```

---

## 总结

C++浮点数的关键要点：

1. **三种类型**：`float`（单精度）、`double`（双精度，推荐默认）、`long double`（扩展精度）
2. **遵循IEEE 754标准**：包含特殊值（Inf、NaN）和规范化表示
3. **存在精度问题**：浮点运算有舍入误差，比较时需使用容差
4. **丰富的数学库**：`<cmath>`提供各种数学函数
5. **注意数值稳定性**：避免灾难性抵消和病态问题

