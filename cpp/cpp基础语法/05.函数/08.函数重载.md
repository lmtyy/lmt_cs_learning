好的，我们来详细介绍一下C++中的函数重载（Function Overloading）。

### 什么是函数重载？

**函数重载** 是C++中的一种特性，它允许在**同一作用域**内定义多个**同名函数**，但这些函数的**参数列表**必须不同（参数的类型、个数或顺序不同）。

函数重载的核心目的是提高代码的可读性和可用性。通过为执行相似操作但作用于不同数据类型的函数赋予相同的名字，程序员可以更容易地记住函数名，并根据上下文传递不同的参数。

---

### 函数重载的规则

要实现函数重载，必须满足以下条件之一（即参数列表必须不同）：

1.  **参数类型不同**
    ```cpp
    void print(int i) {
        cout << "整数: " << i << endl;
    }
    void print(double f) {
        cout << "浮点数: " << f << endl;
    }
    ```

2.  **参数个数不同**
    ```cpp
    void display() {
        cout << "无参数" << endl;
    }
    void display(int a) {
        cout << "一个参数: " << a << endl;
    }
    ```

3.  **参数顺序不同**（前提是类型不同）
    ```cpp
    void func(int a, double b) {
        // ...
    }
    void func(double a, int b) {
        // ...
    }
    ```

**需要注意的是，以下情况不能构成重载：**

*   **仅返回值类型不同**
    ```cpp
    // 错误！这不是有效的重载。
    int getValue();
    double getValue(); // 编译错误
    ```
    编译器无法只通过返回值类型来区分该调用哪个函数。

*   **仅参数名称不同**
    ```cpp
    // 错误！这不是有效的重载。
    void setValue(int a);
    void setValue(int b); // 编译错误
    ```
    对编译器来说，这两个函数的签名（函数名+参数类型列表）是完全一样的。

---

### 函数重载的解析过程

当你调用一个重载函数时，编译器会通过以下步骤来确定调用哪个函数版本：

1.  **名称查找**：首先找到所有同名函数。
2.  **模板处理**：如果存在函数模板，会进行模板特化或实例化，生成候选函数。
3.  **重载决议**：从所有候选函数中选出**最佳匹配**。
    *   **精确匹配**：参数类型完全一致，或者只有微不足道的转换（如数组到指针、函数到函数指针、添加顶层const等）。
    *   **提升匹配**：例如，`char` 或 `short` 提升为 `int`，`float` 提升为 `double`。这种匹配质量很好。
    *   **标准转换匹配**：例如，`int` 转换为 `double`，`double` 转换为 `int`，派生类指针转换为基类指针。
    *   **用户定义的转换**：通过转换构造函数或类型转换运算符实现的匹配。

如果找不到任何匹配的函数，编译器会报错。如果找到多个同样好的匹配，编译器无法决定，就会产生**二义性**错误。

---

### 代码示例

```cpp
#include <iostream>
using namespace std;

// 重载1：参数类型不同 (int)
void print(int i) {
    cout << "整数: " << i << endl;
}

// 重载2：参数类型不同 (double)
void print(double f) {
    cout << "浮点数: " << f << endl;
}

// 重载3：参数个数不同 (两个参数)
void print(const char* s, int times) {
    for (int i = 0; i < times; ++i) {
        cout << "字符串: " << s << endl;
    }
}

// 重载4：参数顺序不同 (int, double) vs (double, int)
void show(int a, double b) {
    cout << "Int: " << a << ", Double: " << b << endl;
}
void show(double a, int b) {
    cout << "Double: " << a << ", Int: " << b << endl;
}

int main() {
    print(5);        // 调用 print(int)
    print(3.14);     // 调用 print(double)
    print("Hello", 3); // 调用 print(const char*, int)

    show(1, 2.5);    // 调用 show(int, double)
    show(3.0, 4);    // 调用 show(double, int)

    return 0;
}
```

**输出：**
```
整数: 5
浮点数: 3.14
字符串: Hello
字符串: Hello
字符串: Hello
Int: 1, Double: 2.5
Double: 3, Int: 4
```

---

### 函数重载与const参数

顶层const（作用于对象本身）不影响重载，但底层const（作用于指针或引用所指向的对象）可以区分重载。

```cpp
// 顶层const - 无法重载，被认为是同一函数
void func(int a);
void func(const int a); // 重复定义错误

// 底层const - 可以重载
void func(int* ptr);        // 用于指向非常量的指针
void func(const int* ptr);  // 用于指向常量的指针，这是有效的重载

void func(int& ref);        // 用于非常量引用
void func(const int& ref);  // 用于常量引用，这是有效的重载
```

---

### 函数重载的注意事项

1.  **避免二义性**：确保重载函数的调用是明确的。常见的二义性来源是默认参数和类型转换。
    ```cpp
    void ambiguous(int a, int b = 10);
    void ambiguous(int a);
    
    ambiguous(5); // 错误！两个函数都匹配，编译器不知道调用哪个。
    ```

2.  **作用域**：重载发生在同一作用域内。如果在一个作用域内声明函数，在派生类作用域内声明同名函数，会**隐藏**而不是重载基类的函数。
    ```cpp
    class Base {
    public:
        void func(int);
    };
    class Derived : public Base {
    public:
        void func(const char*); // 隐藏了Base::func(int)
    };
    
    Derived d;
    d.func("hello"); // 正确，调用Derived::func
    d.func(10);      // 错误！Base::func(int)被隐藏了，需要d.Base::func(10)
    ```

### 总结

| 特性         | 描述                                                         |
| :----------- | :----------------------------------------------------------- |
| **核心思想** | 同一作用域内，函数名相同，参数列表不同。                     |
| **目的**     | 提高代码可读性，为功能相似但参数不同的函数提供统一接口。     |
| **区分依据** | **参数的类型、个数、顺序**。**返回值类型不能**用于区分。     |
| **关键过程** | **重载决议**：编译器根据实参类型寻找最佳匹配函数。           |
| **注意事项** | 避免二义性调用；注意作用域规则（派生类会隐藏基类重载函数）。 |

函数重载是C++实现**编译时多态**的重要方式之一，是面向对象和泛型编程中非常基础且强大的工具。