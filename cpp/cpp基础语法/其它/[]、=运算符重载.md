好 👍，我们来讲一下 **C++ 中运算符重载**里常见的两个：

- `operator[]` —— 下标运算符重载
- `operator=` —— 赋值运算符重载

它们一个用于容器类的访问，另一个用于对象的赋值。

------

## 1. `operator[]` —— 下标运算符重载

### 基本语法

```cpp
T& operator[](size_t index);
const T& operator[](size_t index) const;
```

- 返回 **引用**，这样既能读又能写。
- 建议同时提供 `const` 版本（用于常量对象）。

### 示例：封装动态数组

```cpp
#include <iostream>
using namespace std;

class MyArray {
private:
    int* data;
    size_t size;
public:
    MyArray(size_t n) : size(n) {
        data = new int[n]();
    }
    ~MyArray() { delete[] data; }

    // 下标运算符
    int& operator[](size_t i) {
        return data[i];
    }
    const int& operator[](size_t i) const {
        return data[i];
    }

    size_t getSize() const { return size; }
};

int main() {
    MyArray arr(5);
    arr[0] = 42;             // 写入
    cout << arr[0] << endl;  // 读取

    const MyArray cArr(3);
    // cArr[0] = 5;  // ❌ 不允许修改
    cout << cArr[0] << endl; // OK：只读
}
```

👉 **要点**：

- 返回引用（`int&`），否则 `arr[0] = 42;` 无法生效。
- 常量对象要用 `const` 版本。
- 一般要加越界检查（可以用 `at()` 或断言）。

------

## 2. `operator=` —— 赋值运算符重载

### 背景

- 编译器会默认生成一个 `operator=`（**浅拷贝**）。
- 如果类里有 **指针或资源管理**，必须自己写，避免浅拷贝引发的 **双重释放 (double free)** 问题。

### 基本语法

```cpp
T& operator=(const T& rhs) {
    if (this != &rhs) {
        // 1. 释放已有资源
        // 2. 分配新资源并拷贝 rhs 的内容
    }
    return *this;
}
```

### 示例：深拷贝实现

```cpp
#include <iostream>
#include <cstring>
using namespace std;

class MyString {
private:
    char* data;
public:
    MyString(const char* s = "") {
        data = new char[strlen(s) + 1];
        strcpy(data, s);
    }

    ~MyString() { delete[] data; }

    // 拷贝构造
    MyString(const MyString& other) {
        data = new char[strlen(other.data) + 1];
        strcpy(data, other.data);
    }

    // 赋值运算符
    MyString& operator=(const MyString& other) {
        if (this != &other) {              // 避免自赋值
            delete[] data;                 // 释放旧资源
            data = new char[strlen(other.data) + 1];
            strcpy(data, other.data);      // 深拷贝
        }
        return *this;
    }

    void print() const { cout << data << endl; }
};

int main() {
    MyString a("hello");
    MyString b("world");

    b = a;          // 触发 operator=
    a.print();      // hello
    b.print();      // hello
}
```

👉 **要点**：

- 判断 `this != &rhs`，防止 `a = a;` 自赋值导致提前释放内存。
- 返回 `*this` 的引用，支持链式赋值：`a = b = c;`。

------

## 3. 小总结

- **重载 `[]`**：
  - 常用于自定义容器类，必须返回引用才能修改。
  - 建议提供 `const` 版本。
- **重载 `=`**：
  - 如果类中有资源（指针、文件句柄、socket 等），一定要自己实现深拷贝。
  - 遵循 **Rule of Three / Rule of Five**（写了析构函数，就要考虑写拷贝构造和赋值运算符）。

------

要不要我帮你写一个「数组类」的完整例子，里面同时实现了 `operator[]` 和 `operator=`，这样你能看到它们结合使用的效果？