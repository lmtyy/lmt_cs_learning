# 常量

常量，顾名思义，就是在程序运行期间其值**不可改变**的量。使用常量可以提高代码的可读性、安全性和可维护性。

C++ 提供了几种主要的方式来定义常量：

1.  `const` 关键字
2.  `constexpr` 关键字 (C++11 引入)
3.  预处理器宏 `#define` (现在不推荐用于定义常量)

---

### 1. `const` 关键字

`const` 是 **“常量”** 的最基本、最常用的限定符。它告诉编译器，这个对象的值在初始化后不能被修改。

**语法：**
```cpp
const <数据类型> <常量名> = <初始值>;
// 或者
<数据类型> const <常量名> = <初始值>; // 两种写法等价
```

**特点与用法：**

*   **必须初始化**：`const` 变量在定义时必须赋予初始值，否则会导致编译错误。
*   **运行时常量**：大部分 `const` 变量是**运行时常量**。它的值在运行时初始化，并且在初始化后保持不变。然而，有一些例外情况（如用常量表达式初始化的 `const` 变量可能在编译期就确定）。
*   **作用域**：`const` 变量有明确的作用域（如块作用域、命名空间作用域等），遵循标准的 C++ 作用域规则。
*   **类型安全**：`const` 变量有明确的类型，编译器会进行类型检查。

**示例：**
```cpp
#include <iostream>

int main() {
    const double PI = 3.14159;    // 定义一个双精度浮点型常量
    const int MAX_SIZE = 100;     // 定义一个整型常量

    // PI = 3.14; // 错误！尝试修改常量，编译将失败

    int radius = 5;
    double area = PI * radius * radius; // 使用常量进行计算
    std::cout << "Area is: " << area << std::endl;

    // const 也可以用于指针，有多种形式
    int value = 10;
    const int *ptr1 = &value;      // 指针指向的值是常量，不可通过ptr1修改value
    // *ptr1 = 20;                 // 错误！

    int *const ptr2 = &value;      // 指针本身是常量，不可指向其他地址
    // ptr2 = nullptr;             // 错误！

    const int *const ptr3 = &value; // 指针和它指向的值都是常量

    return 0;
}
```

---

### 2. `constexpr` 关键字 (C++11 引入)

`constexpr` 是 **“常量表达式”** 的缩写。它用于指示编译器，这个变量或函数的值**必须在编译时就能被计算出来**。

**语法：**
```cpp
constexpr <数据类型> <常量名> = <常量表达式>;
```

**特点与用法：**

*   **编译时常量**：`constexpr` 变量是真正的**编译时常量**。它的值在编译阶段就已经确定，并可以被直接嵌入到生成的机器代码中，这能带来性能优化。
*   **更严格的初始化**：初始化器必须是一个**常量表达式**（例如，字面量、其他 `constexpr` 变量、常量表达式函数等）。不能使用运行时才能确定的值来初始化。
*   **更强的约束**：比 `const` 的限制更严格。所有 `constexpr` 变量都隐式地是 `const` 的，但并非所有 `const` 变量都是 `constexpr` 的。
*   **用于数组大小等场景**：在需要编译时常量的地方（如定义数组的大小、模板元编程、`switch-case` 标签等），必须使用 `constexpr`（或者古老的 `#define`），而不能使用运行时常量 `const`。

**示例：**
```cpp
#include <iostream>
#include <array> // C++11 标准数组库

constexpr int square(int x) { // constexpr 函数，可能在编译时求值
    return x * x;
}

int main() {
    constexpr int ARRAY_SIZE = 10;         // 编译时常量
    constexpr double GRAVITY = 9.8;        // 编译时常量

    std::array<int, ARRAY_SIZE> myArray;   // 正确！ARRAY_SIZE是编译时常量，可用于模板参数

    int userInput;
    std::cin >> userInput;
    // constexpr int size = userInput;      // 错误！userInput是运行时值，不能用于初始化constexpr

    const int runtimeConst = userInput;    // 正确！这是一个运行时常量

    constexpr int computedValue = square(5); // 正确！square(5)在编译时计算
    std::cout << computedValue << std::endl; // 输出 25

    return 0;
}
```

**`const` vs `constexpr` 简单对比：**

| 特性           | `const`                  | `constexpr`                            |
| :------------- | :----------------------- | :------------------------------------- |
| **初始化时机** | 通常是运行时（也有例外） | **必须是编译时**                       |
| **初始化器**   | 可以是运行时表达式       | **必须是常量表达式**                   |
| **主要用途**   | 表示运行时不变量         | 表示编译时常量，用于需要编译期值的场景 |
| **严格程度**   | 相对宽松                 | 非常严格                               |

---

### 3. 预处理器宏 `#define` (不推荐)

这是从 C 语言继承过来的方式，在编译的预处理阶段进行简单的文本替换。

**语法：**
```cpp
#define <宏名> <值>
```

**缺点（为什么不推荐）：**

1.  **无类型安全**：它只是文本替换，编译器不会进行类型检查，容易导致难以发现的错误。
2.  **无作用域**：`#define` 定义的宏从定义点开始到文件末尾都有效（除非被 `#undef`），可能会意外影响其他部分的代码。它不受命名空间或类的限制。
3.  **难以调试**：调试器看到的不是宏名，而是被替换后的值，给调试带来困难。

**示例：**
```cpp
#include <iostream>
#define PI 3.14159    // 定义宏
#define MAX(a, b) ((a) > (b) ? (a) : (b)) // 宏函数，更有风险

int main() {
    double area = PI * 5 * 5; // 预处理后变为: double area = 3.14159 * 5 * 5;
    std::cout << area << std::endl;

    int result = MAX(10, 20); // 被替换为: int result = ((10) > (20) ? (10) : (20));
    std::cout << result << std::endl;
    return 0;
}
```

**现代 C++ 中，应优先使用 `const` 或 `constexpr` 来完全取代 `#define` 定义常量的功能。**

---

### 总结与建议

| 方式            | 推荐度   | 说明                                                         |
| :-------------- | :------- | :----------------------------------------------------------- |
| **`constexpr`** | **极高** | 定义**编译时常量**的首选。用于数组大小、模板参数等所有需要编译期确定值的场景。 |
| **`const`**     | **高**   | 定义**运行时常量**的首选。用于那些初始化值在运行时才能确定，但之后保持不变的情况。 |
| **`#define`**   | **避免** | 避免用于定义常量。仅在需要条件编译（`#ifdef`）或某些特殊宏功能时使用。 |

**核心原则：优先使用 `constexpr`，如果不能用 `constexpr`（因为初始值不是常量表达式），则使用 `const`。尽量避免使用 `#define` 来定义常量。**