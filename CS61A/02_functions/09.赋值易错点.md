### **Python 多重赋值与链式赋值的深度解析**

#### **1. 多重赋值（Parallel Assignment）**
**语法**：`var1, var2 = expr1, expr2`  
**作用**：同时为多个变量赋值，按顺序一对一绑定。

**示例**：
```python
x, y, z = 1, "a", [1, 2]  # x=1, y="a", z=[1,2]
```

##### **关键点**
1. **右侧表达式先求值**：  
   Python 会先计算右侧所有表达式的值，再从左到左赋值。  
   ```python
   a, b = 10, a + 1  # 若a原为5，则b=6（先计算a+1，再赋值）
   ```

2. **变量数量必须匹配**：  
   左右两侧的变量和值数量必须一致，否则报错。  
   ```python
   x, y = 1, 2, 3  # ValueError: too many values to unpack
   ```

3. **支持解包操作**：  
   可用于解包元组、列表、字典等可迭代对象。  
   ```python
   point = (3, 4)
   x, y = point  # x=3, y=4
   ```

##### **易错点**
- **交换变量的陷阱**：  
  看似简单的 `a, b = b, a` 实际是创建了一个临时元组，再解包赋值。  
  ```python
  a, b = 1, 2
  a, b = b, a  # 正确交换：a=2, b=1
  ```
  但若误用分步赋值会出错：  
  ```python
  a = b  # a 和 b 现在指向同一对象
  b = a  # 无意义！b 仍指向原值
  ```

---

#### **2. 链式赋值（Chained Assignment）**
**语法**：`var1 = var2 = expr`  
**作用**：将多个变量绑定到同一个对象。

**示例**：
```python
a = b = c = 0  # a, b, c 都指向整数 0
x = y = []     # x 和 y 指向同一个空列表
```

##### **关键点**
1. **共享引用**：  
   所有变量指向 **同一个对象**，对可变对象的修改会影响所有变量。  
   ```python
   x = y = []
   x.append(1)  # y 也会变成 [1]
   ```

2. **执行顺序**：  
   等价于先计算右侧表达式，再从左到右赋值。  
   ```python
   x = y = []  # 等价于：
   # 1. 创建空列表对象 []
   # 2. y = []
   # 3. x = y
   ```

##### **易错点**
- **可变对象的灾难**：  
  链式赋值常用于不可变对象（如 `int`, `str`），但用于可变对象（如 `list`）时容易引发意外。  
  ```python
  a = b = []
  a.append(1)  # b 也会被修改！
  print(b)     # 输出 [1]
  ```
  **修复方法**：显式独立创建对象。  
  ```python
  a = []
  b = []  # a 和 b 指向不同的列表
  ```

- **与多重赋值的区别**：  
  ```python
  x, y = [], []  # 两个独立列表（多重赋值）
  x = y = []     # 两个变量共享同一列表（链式赋值）
  ```

---

### **对比总结**
| **特性**         | **多重赋值 (`x, y = a, b`)** | **链式赋值 (`x = y = a`)**   |
| ---------------- | ---------------------------- | ---------------------------- |
| **对象引用**     | 变量指向不同对象             | 变量指向同一对象             |
| **适用场景**     | 交换变量、解包操作           | 初始化多个变量为相同不可变值 |
| **可变对象风险** | 无（每个变量独立）           | 高风险（共享引用）           |
| **执行顺序**     | 右侧先求值，再从左到右赋值   | 右侧先求值，再从左到右绑定   |

---

### **经典面试题**
**问题**：以下代码的输出是什么？为什么？
```python
a = b = [1]
a += [2]
print(b)
```
**答案**：`[1, 2]`  
**解析**：  
1. `a = b = [1]` 使 `a` 和 `b` 指向同一个列表。  
2. `a += [2]` 就地修改列表（等价于 `a.extend([2])`），因此 `b` 也同步变化。  

**正确写法**（若需独立对象）：
```python
a = [1]
b = [1]  # 或 b = a.copy()
```

---

掌握这些细节后，你将能彻底避免 Python 赋值相关的隐蔽 Bug！